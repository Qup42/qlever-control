#!/bin/bash

# This is the script that is called when calling "qlever" from the command line.
# The script is self-explanatory when you run it. Type ". qlever" for initial
# configuration and then "qlever" or "qlever help" for initial help.
#
# Â© 2022, University of Freiburg, Chair of Algorithms and Data Structures
# Author: Hannah Bast <bast@cs.uni-freiburg.de>

BLUE=$(printf "\033[34m")
RED=$(printf "\033[31m")
GRAY=$(printf "\033[37m")
MAGENTA=$(printf "\033[35m")
BOLD=$(printf "\033[1m")
NORMAL=$(printf "\033[0m")


###
### AVAILABLE ACTIONS (all available via autocompletion)
###

function action_help {
  cat << EOT
${BOLD}QLever help${NORMAL}

The "qlever" script controls ALL things concerning QLever. Before using it the
first time in a particular shell and directory, type ". qlever". This will
enable autocompletion for the command line and create a basic Qleverfile.

QLEVERFILE: You need a file named "QLeverfile" in the directory from which you
are calling the "qlever" script. The initial call to ". qlever" will create one
for you, which you can then modify as you see fit. The QLeverfile controls
settings of the script, the dataset you want to process, the server, whether to
use docker or not, and the QLever UI.

ACTIONS: On the command line, typing TAB after "qlever" gives you the available
actions. You can also execute several actions with one command, for example
"qlever index start log". If you just want to see what an action does, but not
exeute it, append show.  That you can also do for multiple actions, for example
"qlever index start log show".

BINARIES: For the actions "index" and "start", you need QLever's binaries. You
can either use them via docker (USE_DOCKER=1, the default in the Qleverfile), or
compile them on your machine (see "qlever help-install" for instructions). With
docker, all you need is a docker installation. The "qlever" script will
automatically download and run the right images for you.

EOT
}

function action_help_install {
  cat << EOT
${BOLD}QLever install${NORMAL}

If you don't want to use docker for the actions "index" (building an index) and
"start" (starting a server), you have to compile the binaries "IndexBuilderMain"
and "ServerMain" on your machine. As a first step, do the following somewhere on
your machine. We recommend that you have a directory "qlever", with subfolders
for the different components: "qlever-code", "qlever-control", "qlever-indices",
etc.
${BLUE}
git clone --recursive https://github.com/ad-freiburg/qlever qlever-code
cd qlever-code
mkdir -p build && cd build
${NORMAL}
If you are on Ubuntu 18.04 or Ubuntu 20.04, QLever provides two Dockerfile under
qlever-code/master/Dockerfiles . Pick the right one for your machine, consider
all lines starting with RUN and run them from the command line, without the RUN
and with a "sudo" before each "apt", "apt-get", "add-apt-repository", or "tee".
Here is a command line to get the commands automatically from the respective
Dockerfile:
${BLUE}
cat /path/to/qlever-code/Dockerfiles/Dockerfile.Ubuntu20.04 \\
  | sed -En 's/(add-apt|apt|tee)/sudo \1/g; s/^RUN //p' | sed '/^cmake/q'
${NORMAL}
After this, you have the two binaries in your "build" folder. Put the path to
it in your PATH. Then you can use the actions "index" and "start" also with
USE_DOCKER=0 in your Qleverfile.

EOT
}

SHOW=
NOSHOW=

function action_remove_data {
  echo "Removing files specified in RDF_FILES in Qleverfile ..."
  echo
  ls -l "${RDF_FILES}"
  $SHOW rm -f "${RDF_FILES}"
}

function action_download_data {
  if [ -z "${DOWNLOAD_URLS}" ]; then
    echo "${RED}No DOWNLOAD_URLS specified in Qleverfile${NORMAL}"
  else
    echo "Downloading URLs from DOWNLOAD_URLS in Qleverfile ..."
    echo
    $SHOW wget ${DOWNLOAD_URLS}
  fi
}

function action_index {
  if ls ${DB}.index.* > /dev/null 2>&1; then
    echo "${RED}Index exists, delete it first with \"qlever remove-index\" (add \"show\" to find out what gets deleted)${NORMAL}"
  else
    # Create settings.json.
    if jq --version > /dev/null 2>&1; then
      echo ${SETTINGS_JSON} | jq -M '.' > ${DB}.settings.json
    else
      echo ${SETTINGS_JSON} > ${DB}.settings.json
    fi
    # Create prefix definitions
    if [ ! -z "${EXTRACT_PREFIXES}" ]; then eval $SHOW ${EXTRACT_PREFIXES} $NOSHOW; fi
    # Build index.
    eval $SHOW ${INDEXER_CMD}
  fi
}

function action_remove_index {
  $SHOW rm -f ${DB}.index.* ${DB}.vocabulary.* ${DB}.prefixes ${DB}.meta-data.json ${DB}.index-log.txt
  echo "The index files have been removed."
}

function action_index_stats {
  if [ ! -e ${DB}.index-log.txt ]; then echo "${RED}Need file \"${DB}.index-log.txt\"${NORMAL}"; return; fi
  $SHOW readarray -t T < <(sed -En '/INFO:  (Processing|Done|Converting triples|Creating|Index build)/p' ${DB}.index-log.txt | cut -c1-19)
  if [ "${#T[@]}" -lt "6" ]; then echo "${RED}Missing key lines in \"${DB}.index-log.txt\"${NORMAL}"; return; fi
  Ts=$(echo "($(date +%s -d "${T[-1]}") - $(date +%s -d "${T[0]}"))" | bc)
  if [ "${Ts}" -gt "3600" ]; then Tdiv=3600; Tunit="h"; else Tdiv=60; Tunit="min"; fi
  T1=$(echo "($(date +%s -d "${T[1]}") - $(date +%s -d "${T[0]}")) / ${Tdiv}" | bc -l)
  T2=$(echo "($(date +%s -d "${T[2]}") - $(date +%s -d "${T[1]}")) / ${Tdiv}" | bc -l)
  T3=$(echo "($(date +%s -d "${T[3]}") - $(date +%s -d "${T[2]}")) / ${Tdiv}" | bc -l)
  T4=$(echo "($(date +%s -d "${T[4]}") - $(date +%s -d "${T[3]}")) / ${Tdiv}" | bc -l)
  T5=$(echo "($(date +%s -d "${T[5]}") - $(date +%s -d "${T[4]}")) / ${Tdiv}" | bc -l)
  T6=$(echo "($(date +%s -d "${T[6]}") - $(date +%s -d "${T[5]}")) / ${Tdiv}" | bc -l)
  T7=$(echo "($(date +%s -d "${T[7]}") - $(date +%s -d "${T[6]}")) / ${Tdiv}" | bc -l)
  TT=$(echo "($(date +%s -d "${T[-1]}") - $(date +%s -d "${T[0]}")) / ${Tdiv}" | bc -l)
  echo "Time needed for the various phases of the index build"
  echo
  printf "%-23s : %5.1f ${Tunit}\n" "Parse input"            ${T1}
  printf "%-23s : %5.1f ${Tunit}\n" "Build vocabularies"     $(echo "${T2} + ${T4}" | bc)
  printf "%-23s : %5.1f ${Tunit}\n" "Convert to global IDs"  ${T3}
  printf "%-23s : %5.1f ${Tunit}\n" "PSO & POS permutations" ${T5}
  if [ "${#T[@]}" -gt "6" ]; then printf "%-23s : %5.1f ${Tunit}\n" "SPO & SOP permutations" ${T6}; fi
  if [ "${#T[@]}" -gt "7" ]; then printf "%-23s : %5.1f ${Tunit}\n" "OSP & OPS permutations" ${T7}; fi
  echo
  printf "%-23s : %5.1f ${Tunit}\n" "TOTAL index build time" ${TT}
}

function action_start {
  if curl --silent http://localhost:${SERVER_PORT} > /dev/null; then 
    echo "${RED}Server already running on port ${SERVER_PORT}, use \"qlever restart\" or check SERVER_PORT in your Qleverfile${NORMAL}"
    echo "${BLUE}"
    ps -e -o "%p" -o "  %U " -o start_time -o "  %a" \
      | \grep "${SERVER_BINARY} .*-p ${SERVER_PORT}" \
      | \grep -v "grep.*${SERVER_BINARY}"
    printf "${NORMAL}"
  else
    if [ -f "${DB}.index.pso" ] && [ -f "${DB}.index.pos" ]; then
      echo "Starting the QLever server in the background and waiting till it's ready (Ctrl+C will not kill it) ..."
      echo
      rm -f ${DB}.server-log.txt
      eval $SHOW ${SERVER_CMD}
      tail -f -n 10 ${DB}.server-log.txt & PID=$!
      while [ $(curl --silent http://localhost:${SERVER_PORT} > /dev/null; echo $?) != 0 ]; do sleep 1; done
      kill ${PID}
    else
      echo "${RED}Index missing, first build one using \"qlever index\"${NORMAL}"
    fi
  fi
}

function action_stop {
  echo "Stop the QLever server (find and kill manually if it fails) ..."
  echo
  if printf ${BLUE} && pgrep -af "${SERVER_BINARY} -i [^ ]*${DB}" && printf ${NORMAL}; then
    echo
    $SHOW pkill -f "${SERVER_BINARY} -i [^ ]*${DB}" && rm -f ${DB}.server-log.txt $NOSHOW \
      && echo "Killed processes and removed \"${DB}.server-log.txt\""
  else
    echo "${RED}Did not find a running server for \"${DB}\" or could not kill it, try \"qlever status\"${NORMAL}"
  fi
}

function action_restart {
  $SHOW qlever stop $NOSHOW | sed '1,3d'
  $SHOW qlever start $NOSHOW | sed '1,3d'
}

function action_wait {
  tail -f -n 10 ${DB}.server-log.txt & PID=$!
  while [ $(curl --silent http://localhost:$(SERVER_PORT) > /dev/null; echo $?) != 0 ]; do sleep 1; done
  kill $PID
}

function action_log {
  echo "Showing the log (abort with Ctrl+C) ..."
  echo
  $SHOW tail -f -n 10 ${DB}.server-log.txt
}

function action_log_until_server_up {
  $SHOW tail -f -n 10 ${DB}.server-log.txt & PID=$!
  while ! curl --silent http://localhost:${SERVER_PORT} > /dev/null; do sleep 1; done
  kill ${PID}
}


function action_status {
  echo "Showing all processes with command \"${SERVER_BINARY}\" or \"${INDEXER_BINARY}\" on this machine ..."
  echo "${BLUE}"
  $SHOW ps -e -o %p -o %U -o start_time -o rss:10 -o %a | sed -E '1p; /\b('${SERVER_BINARY}'|'${INDEXER_BINARY}')/!d; /bash -c/d' $NOSHOW \
    | awk 'NR==1 {o=$0; a=match($0, $5)} NR > 1 {o=$0; $4=int($4/(1024*1024))"G";} {printf "%-7s %-8s %5s %5s  %s\n", $1, $2, $3, $4, substr(o, a)}'
  printf "${NORMAL}"
  if [ "$(docker container inspect -f '{{.State.Running}}' ${QLEVER_DOCKER_CONTAINER} 2> /dev/null)" == "true" ]; then
    echo "${BLUE}"
    $SHOW docker ps --filter "name=${QLEVER_DOCKER_CONTAINER}"
    printf "${NORMAL}"
  fi
}

# Warmup queries for the autocompletion.
# 
# TODO: This requires a running QLever UI and his currently hard-coded to use
# instances on particular machine (galera.informatik.privat). It will be fixed
# soon.
#
# NOTE: We need -tt here because the "qlever" script calls "make" via a pipe and
# so it does not have a terminal (the error message is "Pseudo-terminal will not
# be allocated because stdin is not a terminal." and "the input device is not a
# TTY"). The manpage for ssh says: "Multiple -t options force tty allocation,
# even if ssh has no local tty." and "-tt" is just a shorthand for "-t -t".in.master:
function action_pin_INTERNAL {
  echo "Launch warmup queries for the QLever UI autocompletion (via galera) ..." 
  $SHOW ssh -tt galera docker exec -it qlever-ui bash -c \"python manage.py warmup ${SLUG} pin\"
}

# Clear the cache.
function action_clear_cache {
  echo "Clearing the cache (unpinned entries only) ..."
  $SHOW curl -Gs ${SERVER_API} --data-urlencode "cmd=clear-cache" $NOSHOW > /dev/null
  curl -Gs ${SERVER_API} --data-urlencode "cmd=cache-stats" \
    | sed 's/[{}",]//g; s/:/: /g; s/^\s\+//' | tr -s " " \
    | numfmt --field=2,5,8,11,14 --grouping
}

function action_clear_cache_complete {
  echo "Clearing the cache completely (including pinned entries) ..."
  $SHOW curl -Gs ${SERVER_API} --data-urlencode "cmd=clear-cache-complete" $NOSHOW > /dev/null
  curl -Gs ${SERVER_API} --data-urlencode "cmd=cache-stats" \
    | sed 's/[{}",]//g; s/:/: /g; s/^\s\+//' | tr -s " " \
    | numfmt --field=2,5,8,11,14 --grouping
}

# Get various settings and statistics.
function action_disk_usage {
  echo "Disk usage of all files in this QLever index, and the size of the input files"
  echo
  $SHOW du -hc ${DB}.index.[ops]* ${DB}.vocabulary.* ${DB}.prefixes ${DB}.meta-data.json
  echo
  # echo && echo "For comparison, the size of the input files" && echo #
  du -hc ${RDF_FILES}
}

function action_cache_stats {
  echo "Show cache statistics (in number of IDs, an ID has 8 bytes) ..."
  $SHOW curl -Gs ${SERVER_API} --data-urlencode "cmd=cache-stats" $NOSHOW \
    | sed 's/[{}",]//g; s/:/: /g; s/^\s\+//' | tr -s " " \
    | numfmt --field=2,5,8,11,14 --grouping
}

function action_memory_usage {
  if docker container inspect -f '{{.State.Running}}' ${QLEVER_DOCKER_CONTAINER} > /dev/null 2>&1; then
    $SHOW docker stats --no-stream \
      --format "Memory usage of docker container ${QLEVER_DOCKER_CONTAINER}: {{.MemUsage}}" \
      ${QLEVER_DOCKER_CONTAINER}
  else
    echo "${RED}Docker container \"${QLEVER_DOCKER_CONTAINER}\" not running${NORMAL}"
  fi
}

function action_server_settings {
  echo "Getting settings from \"${SERVER_API}\" ..."
  $SHOW curl -Gs ${SERVER_API} --data-urlencode "cmd=get-settings" $NOSHOW \
    | sed 's/[{}",]//g; s/:/: /g; s/^\s\+//' | tr -s " "
}

# QLever UI (work in progress).
LOG_FILE=qleverui-log.tmp
ERROR_CMD="(echo && echo \"${BLUE}An error occured, check ${LOG_FILE} for details, the last 10 lines are:${NORMAL}\" && tail ${LOG_FILE} && false)"
QLEVERUI_GIT=git@github.com:ad-freiburg/qlever-ui.git
QLEVERUI_DIR="qlever-ui"
function action_ui {
  > ${LOG_FILE}
  # We need the QLever UI repository.
  if [ ! -d "${QLEVERUI_DIR}" ]; then
    echo "Downloading QLever UI from GitHub ..."
    git clone "${QLEVERUI_GIT}" "${QLEVERUI_DIR}"
  fi
  # Configure using Makefile from QLever UI repo.
  echo "Creating configuration for the QLever UI ..."
  $SHOW make -s -C "${QLEVERUI_DIR}" HOSTNAME=${HOSTNAME} CONFIG_SLUG=${QLEVERUI_CONFIG} BACKEND_PORT=${SERVER_PORT} overwrite_config $NOSHOW \
    >> ${LOG_FILE} 2>&1 || eval ${ERROR_CMD}
  # Launching the web app.
  echo "Launching QLever UI web application ..."
  $SHOW make -s -C "${QLEVERUI_DIR}" HOSTNAME=${HOSTNAME} FRONTEND_PORT=${QLEVERUI_PORT} qlever-ui $NOSHOW \
    >> ${LOG_FILE} 2>&1 || eval ${ERROR_CMD}
  echo
  echo "Looks like it worked, go to http://${HOSTNAME}:${QLEVERUI_PORT} and try out some queries. If it doesn't work, check \"${LOG_FILE}\" for suspicious messages or \"${QLEVERUI_DIR}/Makefile\" for troubleshooting help" | fold -s
}

function action_autocompletion_warmup {
  echo "Launch warmup queries for the QLever UI autocompletion ..."
  $SHOW docker exec -i qlever-ui bash -c "python manage.py warmup ${QLEVERUI_CONFIG} pin" $NOSHOW \
    >> ${LOG_FILE} 2>&1 || eval ${ERROR_CMD}
}

# Create wordsfile and docsfile from all literals of the given NT file.
# Using this as input for a SPARQL+Text index build will effectively enable
# keyword search in literals. To understand how, look at the wordsfile and
# docsfile produced. See git:ad-freiburg/qlever/docs/sparql_and_text.md .
#
function action_text_input_from_nt_literals {
  if [ -f "${QLEVER_BIN_DIR}/../misc/words-and-docs-file-from-nt.py" ]; then
    if [ -f "${DB}.nt.gz" ] && [ ! -f "${DB}.nt" ]; then
      echo "Uncompressing NT file ..."
      zcat "${DB}.nt.gz" > "${DB}.nt"
    fi
    if [ -f "${DB}.nt" ]; then
      echo "Creating text input from ${DB}.nt (experimental), which can then be used for an index build by setting WITH_TEXT=1 ..." | fold -s
      $SHOW python3 ${QLEVER_BIN_DIR}/../misc/words-and-docs-file-from-nt.py ${DB}
    else
      echo "${RED}This requires an NT file ${DB}.nt${NORMAL}"
    fi
  else
    echo "${RED}This requires a working copy of the QLever repository${NORMAL}"
  fi
}

# Do we still need these actions?
function action_update {
  echo "Updating \"qlever\" script ..."
  echo
  if [ -d "${QLEVER_CMD_DIR}/.git" ]; then
    $SHOW cd ${QLEVER_CMD_DIR} && git pull
  else
    echo "${RED}Did not find directory \".git\" in \"${QLEVER_CMD_DIR}\"${NORMAL}"
    echo
  fi
}

function action_where {
  printf "${BLUE}"
  cat << EOT
Directory with "qlever" script : ${QLEVER_CMD_DIR}
Directory with QLever UI repo  : ${QLEVERUI_DIR}
Directory with Qlever binaries : ${QLEVER_BIN_DIR}
${NORMAL}
EOT
}

# Produce list of all input files.
function action_rdf_files {
  $SHOW ls ${RDF_FILES}
}

# Produce the input as fed to the index builder.
function action_cat_files {
  eval $SHOW ${CAT_FILES}
}

function action_docker_on {
  if docker container inspect -f '{{.State.Running}}' ${QLEVER_DOCKER_CONTAINER} > /dev/null 2>&1; then
    echo "${MAGENTA}Docker container \"${QLEVER_DOCKER_CONTAINER}\" already running${NORMAL}"
  else
    docker rm -f "${QLEVER_DOCKER_CONTAINER}" > /dev/null 2> /dev/null
    echo "${MAGENTA}Starting docker container \"${QLEVER_DOCKER_CONTAINER}\" ...${NORMAL}"
    $SHOW docker run -d -u $(id -u):$(id -g) -it -v $(pwd):/index \
      -p ${SERVER_PORT}:${SERVER_PORT} \
      --entrypoint bash \
      --name ${QLEVER_DOCKER_CONTAINER} ${QLEVER_DOCKER_IMAGE} $NOSHOW \
      > /dev/null
    while ! docker container inspect -f '{{.State.Running}}' ${QLEVER_DOCKER_CONTAINER} > /dev/null 2>&1; do sleep 0.1; done
    # $SHOW docker cp ${QLEVER_CMD_DIR}/qlever \
    #   ${QLEVER_DOCKER_CONTAINER}:/index $NOSHOW \
    #   > /dev/null #
  fi
  echo "${BLUE}"
  docker ps --filter "name=${QLEVER_DOCKER_CONTAINER}"
  printf "${NORMAL}"
}

function action_docker_off {
  $SHOW docker rm -f "${QLEVER_DOCKER_CONTAINER}"
}

QLEVER_BIN_DIR=/local/data/qlever/qlever-code/build

###
### CONFIGURATION (when called with . qlever or if we need to)
###

QLEVER_CMD="${BASH_SOURCE[0]}"   # Command of this script
QLEVER_CMD_DIR=$(cd -- "$(dirname -- "${QLEVER_CMD}")" &> /dev/null && pwd)

# If not called with ". qlever" and completions or the Qleverfile are missing,
# tell the user to run ". qlever" once for full functionality. Note that bash
# autocompletion can only be activated by "sourcing" the respective commands
# (the ". qlever" is equivalent to "source qlever"). If the Qleverfile has
# BASH_COMPLETION = 0, don't mind the autocompletion.
if [ ${BASH_SOURCE[0]} == $0 ] \
  && ( ( [ -z "${QLEVER_COMPLETIONS}" ] && [ "${BASH_COMPLETION}" != "0" ] ) || \
       [ ! -e Qleverfile ] ); then
    cat << EOT

Bash completion not activated or no Qleverfile exists or both. Please run the
qlever configuration once as follows (an existing Qleverfile will not be
overwritten, don't worry): 

${BLUE}. ${QLEVER_CMD}${NORMAL}

Afterwards you can just call "qlever" (without the dot and without specifying
the path). If you don't care about bash autocompletion or it doesn't work on
your system, set BASH_COMPLETION = 0 in your Qleverfile.

EOT
    exit
fi

# If called with ". qlever", setup what is not already setup: the PATH, the bash
# autocompletion (unless user don't want it), the QLeverfile.
if [ "${QLEVER_CMD}" != "$0" ]; then

  # PATH: Check if QLEVER_CMD_DIR is in the path and if not add it to the path.
  # ALso check if 
  echo
  echo "${BOLD}Checking your PATH ...${NORMAL}"
  echo
  for DIR in ${QLEVER_CMD_DIR} ${QLEVER_BIN_DIR}; do
    if [[ ":${PATH}:" == *":${DIR}:"* ]]; then
      echo "The directory \"${DIR}\" is already contained in your PATH"
    else
      export PATH=${PATH}:${DIR}
      echo "Added the directory \"${DIR}\" to your PATH"
    fi
  done
  echo

  # If we called ". qlever path" (just to set the paths), exit here.
  if [ "$*" == "path" ]; then
    echo "${NORMAL}Called \". qlever path\", so leaving now${NORMAL}"
    echo
    return
  fi

  # Bash autocompletion: Set completions with "complete -W" and store the
  # completions in "QLEVER_COMPLETIONS". We need the latter so that we know that
  # the completions are set (complete -p does not work in a subshell).
  COMPLETIONS_FILE=no_longer_needed
  echo "${BOLD}Setting up bash autocompletion ...${NORMAL}"
  echo
  COMPLETIONS=$(declare -F | sed -En 's/^declare -f action_([a-zA-Z_.-]+)$/\1/p' | sed 's/_/-/g' | paste -sd" ")
  export QLEVER_COMPLETIONS="${COMPLETIONS}"
  complete -W "${COMPLETIONS}" qlever
  eval ${COMPLETIONS_CMD}
  echo "Done, the following completions are now available:"
  echo
  echo "${BLUE}$(echo ${QLEVER_COMPLETIONS} | fold -s)${NORMAL}"
  echo

  # If we called ". qlever init" (for use in .bashrc, where we only want to set
  # the PATH and activate the autocompletion), exit here.
  if [ "$*" == "shell_init" ]; then
    echo "${NORMAL}Called \". qlever shell_init\", so leaving now${NORMAL}"
    echo
    return
  fi

  # QLeverfile: If it's not there yet, create a basic one (with good guesses for
  # some basic settings). Never overwrite an existing one, it has to be removed
  # explicitly by the user.
  if [ -e Qleverfile ]; then
    echo "${BOLD}Checking Qleverfile ...${NORMAL}"
    echo
    cat << EOT
There is alreay a QLeverfile in this directory. If you want a freshly generated
basic Qleverfile, remove or move the existing one and run ". qlever" again.

EOT
  else
    echo "${BOLD}Creating new Qleverfile ...${NORMAL}"
    echo
    # If a file with suffix .ttl or .nt exists, use the basename as the basename
    # for the index files (the DB variable in the configuration) and pick the
    # right "cat" command according to the suffix. If several such files exist,
    # take the largest one. If no such file exists, leave the basename empty and
    # for the user to set.
    RDF_FILES=$(ls -S | egrep "\.(ttl|nt)(\.(gz|bz|bz2|xz))?\$" | head -1)
    CAT=cat
    if [ ! -z ${RDF_FILES} ]; then
      DB=${RDF_FILES/.*/}
      if [[ ${RDF_FILES} =~ .gz$ ]]; then CAT=zcat; fi
      if [[ ${RDF_FILES} =~ .bz2?$ ]]; then CAT=bzcat; fi
      if [[ ${RDF_FILES} =~ .xz$ ]]; then CAT=xzcat; fi
      QLEVERUI_CONFIG=${DB}
    else
      DB=must_specify
      INPUT_FILE=must_specifiy
      QLEVERUI_CONFIG=default
    fi
    # Default configuration parameters.
    read -r -d "" INDEXER_SETTINGS << EOT
DB               = ${DB}
RDF_FILES        = ${RDF_FILES}
CAT_FILES        = "${CAT} \${RDF_FILES}"
WITH_TEXT        = false
SETTINGS_JSON    = '{ "num-triples-per-batch": 10000000 }'
EOT
    read -r -d "" SERVER_SETTINGS << EOT
HOSTNAME                       = $(hostname -f)
SERVER_PORT                    = 7001
MEMORY_FOR_QUERIES             = 10
CACHE_MAX_SIZE_GB              = 5
CACHE_MAX_SIZE_GB_SINGLE_ENTRY = 1
CACHE_MAX_NUM_ENTRIES          = 100
EOT
    # Pre-configure according to first argument (if known).
    if [ "$1" == "olympics" ]; then
      DB=olympics
      read -r -d "" INDEXER_SETTINGS << EOT
DB                = ${DB}
RDF_FILES         = "olympics-nt-nodup.zip"
CAT_FILES         = "unzip -q -c olympics-nt-nodup.zip"
SETTINGS_JSON     = '{ "ascii-prefixes-only": true, "num-triples-per-batch": 10000000 }'
DOWNLOAD_URLS     = "https://github.com/wallscope/olympics-rdf/raw/master/data/olympics-nt-nodup.zip"
EOT
      read -r -d "" SERVER_SETTINGS << EOT
HOSTNAME                       = $(hostname -f)
SERVER_PORT                    = 7019
MEMORY_FOR_QUERIES             = 10
CACHE_MAX_SIZE_GB              = 5
CACHE_MAX_SIZE_GB_SINGLE_ENTRY = 1
CACHE_MAX_NUM_ENTRIES          = 100
EOT
    elif [ "$1" == "wikidata" ]; then
      DB=wikidata-latest
      read -r -d "" INDEXER_SETTINGS << EOT
DB                = ${DB}
RDF_FILES         = "latest-lexemes.ttl.bz2 latest-all.ttl.bz2"
EXTRACT_PREFIXES  = "for F in \${RDF_FILES}; do bzcat \\\$F | head -1000 | \grep ^@prefix; done | sort -u > ${DB}.prefix-definitions"
CAT_FILES         = "bzcat -f ${DB}.prefix-definitions \${RDF_FILES}"
WITH_TEXT         = false
STXXL_MEMORY_GB   = 40
SETTINGS_JSON     = '{ "languages-internal": ["en"], "prefixes-external": [ "<http://www.wikidata.org/entity/statement", "<http://www.wikidata.org/value", "<http://www.wikidata.org/reference" ], "locale": { "language": "en", "country": "US", "ignore-punctuation": true }, "ascii-prefixes-only": true, "num-triples-per-batch": 25000000 }'
DOWNLOAD_URLS     = "https://dumps.wikimedia.org/wikidatawiki/entities/latest-all.ttl.bz2 https://dumps.wikimedia.org/wikidatawiki/entities/latest-lexemes.ttl.bz2"
EOT
      read -r -d "" SERVER_SETTINGS << EOT
HOSTNAME                       = $(hostname -f)
SERVER_PORT                    = 7001
MEMORY_FOR_QUERIES             = 40
CACHE_MAX_SIZE_GB              = 30
CACHE_MAX_SIZE_GB_SINGLE_ENTRY = 5
CACHE_MAX_NUM_ENTRIES          = 100
EOT
    elif [ "$1" == "dblp" ]; then
      DB=dblp
      read -r -d "" INDEXER_SETTINGS << EOT
DB                = ${DB}
RDF_FILES         = dblp.nt.gz
CAT_FILES         = "zcat \${RDF_FILES}"
WITH_TEXT         = true
SETTINGS_JSON    = '{ "ascii-prefixes-only": true, "num-triples-per-batch": 10000000 }'
DOWNLOAD_URLS     = "https://dblp.org/rdf/dblp.nt.gz"
EOT
      read -r -d "" SERVER_SETTINGS << EOT
HOSTNAME                       = $(hostname -f)
SERVER_PORT                    = 7015
MEMORY_FOR_QUERIES             = 10
CACHE_MAX_SIZE_GB              = 5
CACHE_MAX_SIZE_GB_SINGLE_ENTRY = 1
CACHE_MAX_NUM_ENTRIES          = 100
EOT
    fi
    cat << EOT > Qleverfile
# Qleverfile for folder $(pwd)
# Automatically created on $(date).
# Modify or expand as you see fit.

# Indexer settings
${INDEXER_SETTINGS}

# Server settings
${SERVER_SETTINGS}

# QLever binaries
QLEVER_BIN_DIR          = ${QLEVER_BIN_DIR}
USE_DOCKER              = false
QLEVER_DOCKER_IMAGE     = adfreiburg/qlever
QLEVER_DOCKER_CONTAINER = qlever.${DB}

# QLever UI
QLEVERUI_PORT   = 7000
QLEVERUI_DIR    = ${QLEVERUI_DIR}
QLEVERUI_CONFIG = ${QLEVERUI_CONFIG}
EOT
    cat << EOT
There was no "Qleverfile" in this directory yet, so I created one for you. A
Qleverfile contains basic configuration telling the "qlever" command how to do
certain things. Please check and modify as you see fit.

EOT
# ${BLUE}$(cat Qleverfile)${NORMAL}
  fi

  # Settings file: If it's not there yet, create an empty one.
  if [ ! -e ${DB}.settings.json ]; then
    echo "${BOLD}Checking .settings.json file ...${NORMAL}"
    echo
    echo "{}" > ${DB}.settings.json
    cat << EOT
The index builder currently also requires a file "${DB}.settings.json", and I
created an empty one for you. In this file, you can specify specialized settings
for the indexer, for example: prefixes of IRIs for which the names are stored on
disk (to save RAM), the locale by which literals are sorted, the batch size used
by the indexer (default: 10M), and whether the input is well behaved in a
certain way (which enables faster indexing). See the QLever Wiki for more
information.

EOT
  fi

  # DONE: give the user a short heads up what they can do now.
  cat << EOT
${BOLD}Setup is complete${NORMAL}

Type "qlever" and use autocompletion to see which actions are available. Add a
"show" in the end to see what an action does without executing it (for example,
"qlever index show"). Typing "qlever" without arguments gives some basic help
and pointers for further help. Edit your local "Qleverfile" to change settings.

EOT
  return
fi


###
### BASIC HELP AND INSTALL INFO
###
### Note that this must come after the code for ". qlever" (which is also called
### without arguments).
###

if [ -z "$*" ] || [ "$*" == "help" ]; then
  echo
  action_help
  exit
fi
if [ "$*" == "help-install" ]; then
  echo
  action_help_install
  exit
fi

# Welcome message. TODO: remove this eventually.
echo
echo "${GRAY}This is the \"qlever\" script, call without argument for help${NORMAL}"
echo


###
### VARIABLE ASSIGNMENTS
###
### 1. Default settings
### 2. Read from Qleverfile (space around = allowed)
### 3. Computed derived variables
###

# Some default settings.
APP_DIR=$(pwd)                   # Where the script was called from
DB=must_specify
USE_DOCKER=0
WITH_TEXT=0
QLEVER_DOCKER_IMAGE=adfreiburg/qlever
HOSTNAME=must_specify     # backend host
SERVER_PORT=must_specify  # backend port
QLEVERUI_PORT=7000        # frontend port
MEMORY_FOR_QUERIES=30             # in GB
CACHE_MAX_SIZE_GB=30              # in GB
CACHE_MAX_SIZE_GB_SINGLE_ENTRY=5  # in GB
CACHE_MAX_NUM_ENTRIES=1000
ADMIN_TOKEN=              # for actions requiring privilege

# Read from Qleverfile (only lines that look like an assignment are considered,
# space around = allowed).
# echo "$(cat Qleverfile | sed -En 's/^([A-Z_]+)\s*=\s*(.*)$/\1=\2/p')"
# echo
eval "$(cat Qleverfile | sed -En 's/^([A-Z_]+)\s*=\s*(.*)$/\1=\2/p')"
# echo "CAT_FILES = \"${CAT_FILES}\""

# Derived variables. TODO: Only if if not explicitly defined in Qleverfile.
QLEVER_DOCKER_CONTAINER=qlever.${DB}
DB_BASE=$(echo ${DB} | sed 's/\..*$//')
SLUG=${DB_BASE} # URL slug used in the QLever UI
INDEXER_BINARY=IndexBuilderMain
INDEXER_OPTIONS="-F ttl -K ${DB} -f - -i ${DB} -s ${DB_BASE}.settings.json"
if [[ :1:yes:true: == *:${PSO_AND_POS_ONLY}:* ]]; then
  INDEXER_OPTIONS="${INDEXER_OPTIONS} --only-pso-and-pos-permutations --no-patterns"
fi
if [ "${STXXL_MEMORY_GB}" ]; then
  INDEXER_OPTIONS="${INDEXER_OPTIONS} --stxxl-memory-gb ${STXXL_MEMORY_GB}"
fi
if [[ :1:yes:true: == *:${WITH_TEXT}:* ]]; then
  INDEXER_OPTIONS="${INDEXER_OPTIONS} -w ${DB}.wordsfile.tsv -d ${DB}.docsfile.tsv"
fi
if [[ :1:yes:true: == *:${USE_DOCKER}:* ]]; then
  INDEXER_CMD="docker exec -it -w /index ${QLEVER_DOCKER_CONTAINER} bash -c \"${CAT_FILES} | ${INDEXER_BINARY} ${INDEXER_OPTIONS} | tee ${DB}.index-log.txt\""
else
  INDEXER_CMD="${CAT_FILES} | ${INDEXER_BINARY} ${INDEXER_OPTIONS} | tee ${DB}.index-log.txt"
fi
SERVER_BINARY=ServerMain
SERVER_OPTIONS="-i ${DB} -j 8 -m ${MEMORY_FOR_QUERIES} -c ${CACHE_MAX_SIZE_GB} -e ${CACHE_MAX_SIZE_GB_SINGLE_ENTRY} -k ${CACHE_MAX_NUM_ENTRIES} -p ${SERVER_PORT}${TEXT_OPTIONS_START}"
if [[ :1:yes:true: == *:${PSO_AND_POS_ONLY}:* ]]; then
  SERVER_OPTIONS="${SERVER_OPTIONS} --only-pso-and-pos-permutations --no-patterns"
fi
if [[ :1:yes:true: == *:${WITH_TEXT}:* ]]; then
  SERVER_OPTIONS="${SERVER_OPTIONS} -t"
fi
if [[ :1:yes:true: == *:${USE_DOCKER}:* ]]; then
  SERVER_CMD="docker exec -d -w /index ${QLEVER_DOCKER_CONTAINER} bash -c \"${SERVER_BINARY} ${SERVER_OPTIONS} > ${DB}.server-log.txt\""
  # SERVER_CMD="docker exec -d -w /index ${QLEVER_DOCKER_CONTAINER} \"${SERVER_BINARY} ${SERVER_OPTIONS} > ${DB}.server-log.txt\""
else
  SERVER_CMD="${SERVER_BINARY} ${SERVER_OPTIONS} > ${DB}.server-log.txt &"
fi
SERVER_API=http://${HOSTNAME}:${SERVER_PORT}



# Variant of make that reads the master Qleverfile (using GET_MASTER_QLEVERFILE)
# and the local Qleverfile (in the directory from which this script is called).
# The -s option stands for "silent" (do not show the commands while executing
# them).
function qlever_make {
  QLEVERFILE_ARG=
  if [ -e "${APP_DIR}/Qleverfile" ]; then
    QLEVERFILE_ARG=" -f ${APP_DIR}/Qleverfile"
  fi
  get_master_qleverfile | make -s -f - ${QLEVERFILE_ARG} "$@"
}

# Like the above, but only show what would be executed (using the -n option of
# "make"), in blue. Leave out command lines that end with #.
function qlever_make_show {
  printf "${BLUE}"
  get_master_qleverfile \
      | make -f - -f ${APP_DIR}/Qleverfile -n "$@" \
      | egrep -v "#.?\$" | sed 's/^\s*//; s/\s?*\\$//' \
      | sed 's/^: #/#/'
  printf "${NORMAL}"
}

# Execute action function (given as argument $1).
function execute_action {
  ACTION_FUNCTION=$1
  if [ "$(declare -f ${ACTION_FUNCTION})" ]; then
    # echo "Executing function \"${ACTION_FUNCTION}\" ..."
    # echo
    eval ${ACTION_FUNCTION}
  else
    echo "${RED}Action function \"$1\" not defined${NORMAL}"
  fi
}

# Show selected code of action function (given as argument $1).
function show_action {
  QUOTE=\"
  DOLLAR=\$
  ACTION_FUNCTION="$1"
  if [ "$(declare -f ${ACTION_FUNCTION})" ]; then
    printf "${BLUE}"
    # This miracle code show the code of the action function. It works as
    # follows:
    # 1. The declare -t gives the full code (as written above).
    # 2. The first sed filters out the lines starting with $SHOW and removing any
    # parts after $NOSHOW (this gives us control which part to show).
    # 3. The second sed temporarily replaces all $ that are not followed by a {
    # and all " by ${DOLLAR} and ${QUOTE}, respsectively. That way, these will
    # be be preserved (and not get interpreted somehow).
    # 4. The last part expands all the ${...} variables (without the eval, no
    # expansion would happen), including the ${DOLLAR} and ${QUOTE} introduced
    # in the previous step.
    # 5. Remove empty lines (these correpond to commands which are only exeuted
    # under certain circumstances)
    declare -f ${ACTION_FUNCTION} \
      | sed -En 's/\s+\$NOSHOW.*$//; s/;$//; s/^.*\$SHOW //p' \
      | sed -En 's/"/${QUOTE}/g; s/\$([^{])/${DOLLAR}\1/g; p' \
      | while read LINE; do eval "echo \"${LINE}\""; done \
      | sed -E '/^\s*$/d'
    printf "${NORMAL}"
  else
    echo "${RED}Action function \"$1\" not defined${NORMAL}"
  fi
}

# Command to leave the script ("return" when the script is sourced, "exit" when
# it is called normally, that is, within its own subshell).
EXIT=exit
if [ ${QLEVER_CMD} != $0 ]; then EXIT=return; fi
function exit_qlever { eval ${EXIT}; }



# First separate the variable assignment arguments from the others. The
# assignment will go in VARS, the rest will stay in $@ (both arrays).
# VARS=( "QLEVER_CMD=${QLEVER_CMD}" "QLEVER_CMD_DIR=${QLEVER_CMD_DIR}" )
# VARS=()
# # OPT=""
# for ARG do
#   shift
#   # [[ "${ARG}" =~ ^--$ ]] && OPT="${ARG}" && continue
#   [[ "${ARG}" =~ ^[A-Z_]+= ]] && VARS+=( "${ARG}" ) && continue
#   set -- "$@" "${ARG}"
# done
# # for VAR in "${VARS[@]}"; do echo "VAR = \"${VAR}\""; done
# # for ARG in "$@"; do echo "ARG = \"${ARG}\""; done
# # echo
# 
# # Special command "show-config" (for debugging, not one of the completions).
# if [ "$*" == "show-config" ]; then
#   echo "${BOLD}${MAGENTA}Secret action \"show-config\":${NORMAL}"
#   echo
#   cat << EOT
# Showing the settings of some variables after they went through "make" and then
# exported to the "qlever" script again (for debugging). If you call the script
# with a variable assignment as in "qlever USE_DOCKER=0 ...", that value should
# overrule the one from the QLeverfile.
# EOT
#   echo "${BLUE}"
#   qlever_make "${VARS[@]}" export.HIDDEN
#   echo "${NORMAL}"
#   eval ${EXIT}
# fi
# 
# # Actually do these assignments. NO: this is already done above!
# $(qlever_make "${VARS[@]}" export.HIDDEN)
# eval $(qlever_make "${VARS[@]}" export.HIDDEN)




###
### WHAT THE SCRIPT ACTUALLY DOES (it's basically a wrapper for "make")
###

# For selected actions: If USE_DOCKER=1 check if docker container is running
# and if not run it.
USE_DOCKER_ACTIONS=:start:index:
if [[ ${USE_DOCKER_ACTIONS} == *:"$ARG":* ]]; then
  if [ "${USE_DOCKER}" == "1" ]; then
    if [ "$(docker container inspect -f '{{.State.Running}}' ${QLEVER_DOCKER_CONTAINER} 2> /dev/null)" == "true" ]; then
      echo "${MAGENTA}Using the already running docker container \"${QLEVER_DOCKER_CONTAINER}\"${NORMAL}"
      echo
    else
      echo "${MAGENTA}Starting new docker container \"${QLEVER_DOCKER_CONTAINER}\"${NORMAL}"
      echo
      qlever_make_show "${VARS[@]}" QLEVER_CMD_DIR="${QLEVER_CMD_DIR}" docker-run.HIDDEN
      echo
      qlever_make QLEVER_CMD_DIR="${QLEVER_CMD_DIR}" "${VARS[@]}" docker-run.HIDDEN
    fi
  else
    if [ "$(docker container inspect -f '{{.State.Running}}' ${QLEVER_DOCKER_CONTAINER} 2> /dev/null)" == "true" ]; then
      echo "${MAGENTA}USE_DOCKER=0 but found docker container \"${QLEVER_DOCKER_CONTAINER}\", removing it ...${NORMAL}"
      echo
      qlever_make_show "${VARS[@]}" docker-remove.HIDDEN
      echo
      qlever_make "${VARS[@]}" docker-remove.HIDDEN
    fi
  fi
fi


# If the last argument is "show", just show the commands, but don't execute
# them. The first for loop is a portable hack to get the last argument.
for LAST; do true; done
if [ "${LAST}" == "show" ]; then
  echo "${BOLD}Just showing what would be executed${NORMAL}"
  echo
  for ARG in "$@"; do
    if [ "${ARG}" != "show" ]; then
      ACTION_FUNCTION=action_$(echo ${ARG} | sed 's/-/_/g')
      if [ "$(declare -f ${ACTION_FUNCTION})" ]; then
        echo "\"${ARG}\" would execute the following:"
        echo
        show_action "${ACTION_FUNCTION}"
        # qlever_make_show "${VARS[@]}" "${ARG}"
        echo
      else
        echo "${RED}Action \"${ARG}\" not defined, use the autocompletion${NORMAL}"
        echo
      fi
    fi
  done
  exit
fi

# For each action, check whether the corresponding action function exists, and
# if yes, show the command and then execute it.
for ARG in "$@"; do
  # If USE_DOCKER=1 and action requires docker, make sure it's running.
  USE_DOCKER_ACTIONS=:start:index:
  if [[ ${USE_DOCKER_ACTIONS} == *:"$ARG":* ]]; then
    if [ "${USE_DOCKER}" == "1" ]; then
      if ! docker container inspect -f '{{.State.Running}}' ${QLEVER_DOCKER_CONTAINER} > /dev/null 2>&1; then
        execute_action action_docker_on
        echo
      fi
    fi
  fi
  # Now execute the action.
  echo "${BOLD}Executing \"${ARG}\":${NORMAL}"
  echo
  ACTION_FUNCTION=action_$(echo ${ARG} | sed 's/-/_/g')
  if [ "$(declare -f ${ACTION_FUNCTION})" ]; then
    if show_action "${ACTION_FUNCTION}"; then
      echo
      execute_action "${ACTION_FUNCTION}"
      echo
    fi
  else
    echo "${RED}Action \"${ARG}\" not defined, use the autocompletion${NORMAL}"
    echo
  fi
done
