#!/bin/bash

# This is the script that is called when calling "qlever" from the command line.
# It essentially calls "make", using the "Qleverfile" in the QLever home and in
# the current directory as Makefiles.
#
# Â© 2022, University of Freiburg, Chair of Algorithms and Data Structures
# Author: Hannah Bast <bast@cs.uni-freiburg.de>

BLUE=$(printf "\033[34m")
RED=$(printf "\033[31m")
GRAY=$(printf "\033[37m")
BOLD=$(printf "\033[1m")
NORMAL=$(printf "\033[0m")

# The command of this sript, as called (with relative,  absolute, or no path).
QLEVER_CMD="${BASH_SOURCE[0]}"

# Get the absolute path of QLEVER_CMD (assuming it's not a symbolic link). Note:
# the trick is to just "cd" there and then use "pwd", all in a subshell. For a
# hack that also works for symbolic links, see https://tinyurl.com/4jsurr86 .
QLEVER_CMD_DIR=$( cd -- "$( dirname -- "${QLEVER_CMD}" )" &> /dev/null && pwd )

# To get the directory from where this script has been called, we can simply use
# "pwd".
APP_DIR=$(pwd)

# Get the master Qleverfile (everything after __DATA__ in this file, see below).
function get_master_qleverfile {
  sed -e '1,/^__DATA__/d' ${QLEVER_CMD}
}

# Variant of make that reads the master Qleverfile (using GET_MASTER_QLEVERFILE)
# and the local Qleverfile (in the directory from which this script is called).
# The -s option stands for "silent" (do not show the commands while executing
# them).
function qlever_make {
  get_master_qleverfile \
      | make -s -f - -f ${APP_DIR}/Qleverfile "$@" #2> /dev/null
}

# Like the above, but only show what would be executed (using the -n option of
# "make"), in blue. Leave out command lines that end with #.
function qlever_make_show {
  printf "${BLUE}"
  get_master_qleverfile \
      | make -f - -f ${APP_DIR}/Qleverfile -n "$@" \
      | egrep -v "#.?\$" | sed 's/^\s*//; s/\s?*\\$//'
  printf "${NORMAL}"
}

# Command to leave the script ("return" when the script is sourced, "exit" when
# it is called normally, that is, within its own subshell).
EXIT=exit
if [ ${QLEVER_CMD} != $0 ]; then EXIT=return; fi

echo
echo "${GRAY}Called \"${QLEVER_CMD}\" from \"${APP_DIR}\"${NORMAL}"
echo

# With arguments "reset", remove completions and local Qleverfile. TODO: warn
# before actually doing this because the Qleverfile might contain valuable
# informationC, so for now we are moving it.
if [ "${QLEVER_CMD}" != "$0" ] && [ ! -z "$*" ] && [ "$*" == "reset" ]; then
  cat << EOT
${BOLD}Resetting configuration${NORMAL}

Regenerating the completions. The QLeverfile is not regenerated. If you want to
regenerate it, remove it and run ". qlever reset" again.

EOT
  complete -r qlever 2> /dev/null
  rm -f qlever.completions
  # Don't touch the QLeverfile for now.
  # if [ -e Qleverfile ]; then
  #   QLEVERFILE_BACKUP=DELETE/Qleverfile.DELETED_$(date +%Y%m%dT%H%M)
  #   echo "Moving Qleverfile to ${QLEVERFILE_BACKUP}"
  #   echo
  #   mv -f Qleverfile ${QLEVERFILE_BACKUP}
  # fi
  # eval ${EXIT}
fi

# If there is COMPLETIONS_FILE yet, create it. For that we have to first ask the
# user to call the script with "source" or "." (it's the only way to activate
# bash completion).
COMPLETIONS_FILE=qlever.completions
if [ ! -e ${COMPLETIONS_FILE} ]; then
  # echo "\${BASH_SOURCE[0]}: ${BASH_SOURCE[0]}"
  # echo "\$0=$0"
  if [ ${BASH_SOURCE[0]} == $0 ]; then
    cat << EOT
It seems you are running this script for the first time in this shell and
directory. Please run it once as follows:

${BLUE}. qlever${NORMAL}

Afterwards you can just call "qlever" again (without the dot), and you will have
bash autocompletion available. If you don't care about bash autocompletion or
something doesn't work, just create an empty file ${COMPLETIONS_FILE} before
your proceed.

EOT
    eval ${EXIT}
  else
    # CASE 1.2: This script is being sourced -> activate bash completions and
    # write the completions to COMPLETIONS_FILE.
    cat << EOT
${BOLD}Settting up qlever script${NORMAL}

EOT
    # Adding directory of QLEVER_CMD, unless it's already there.
    # Activating bash autocompletion.
    COMPLETIONS=$(get_master_qleverfile | \grep -oE "^[a-zA-Z_-]+:" | sed 's/:$//' | paste -sd" ")
    echo "${COMPLETIONS}" > ${COMPLETIONS_FILE}
    complete -W "${COMPLETIONS}" qlever
    cat << EOT
Activated bash autocompletion. The following completions will be available:

${BLUE}$(fold -s  ${COMPLETIONS_FILE})${NORMAL}

EOT
  fi
fi

# If the is no Qleverfile in this directory yet, create a basic one.
if [ ! -e Qleverfile ]; then
  # If a file with suffix .ttl or .nt exists, use the basename as the basename
  # for the index files (the DB variable in the configuration). If several such
  # files exist, take the largest one. If no such file exists, leave the
  # basename empty and for the user to set.
  INPUT_FILE=$(ls -S | egrep "\.(ttl|nt)(\.(gz|bz|bz2|xz))?\$" | head -1)
  if [ ! -z ${INPUT_FILE} ]; then DB=${INPUT_FILE/.*/}; else DB=; fi
    # Get right version of "cat", depending on suffix.
    CAT=cat
    if [[ ${INPUT_FILE} =~ \.gz\$ ]]; then CAT=zcat; fi
    if [[ ${INPUT_FILE} =~ \.bz\$ ]]; then CAT=bzcat; fi
    if [[ ${INPUT_FILE} =~ \.bz2\$ ]]; then CAT=bzca; fi
    if [[ ${INPUT_FILE} =~ \.xz\$ ]]; then CAT=xzca; fi
    cat << EOT > Qleverfile
# Qleverfile for folder $(pwd) .
# Created on $(date).
# Modify or expand as you see fit.

DB        = ${DB}
RDF_FILES = ${INPUT_FILE}
CAT_FILES = ${CAT} \$(RDF_FILES)
PORT      = 7001
EOT
    cat << EOT
There was no Qleverfile in this directory yet. A Qleverfile contains basic
configuration telling the "qlever" command how to do certain things. I now
created the following basic Qleverfile.

${BLUE}$(cat Qleverfile)${NORMAL}

EOT
fi

# If the script was sourced (initial setup), exit (will be "return") now.
if [ ${QLEVER_CMD} != $0 ]; then
  cat << EOT | fold -s
Setup complete, you can use "qlever" normally. If you want to redo the
setup, you can run ". qlever reset".

EOT
  eval ${EXIT}
fi

# When calling script with no arguments, show the config. TODO: Give the user
# some more information here.
if [ -z "$*" ]; then
  qlever_make
  if [ -e ${COMPLETIONS_FILE} ]; then
    cat << EOT
All completions:

${BLUE}$(cat ${COMPLETIONS_FILE} | fold -s)${NORMAL}

To see what a particular command would do (without executing it), just type
something like "qlever index show" (single command) or "qlever start log show"
(multiple commands)

EOT
  fi
  eval ${EXIT}
fi

# If the last argument is "show", just show the commands, but don't execute
# them. The first for loop is a portable hack to get the last argument.
for LAST; do true; done
if [ "${LAST}" == "show" ]; then
  echo "${BOLD}Just showing what would be executed${NORMAL}"
  echo
  for ARG in "$@"; do
    if [ "${ARG}" != "show" ]; then
      echo "\"${ARG}\" would execute the following:"
      echo
      qlever_make_show "${ARG}"
      echo
    fi
  done
  eval ${EXIT}
fi

# Normal execution of script using make with two Makefiles. The first Makefile
# is everything after __DATA__ below (that part is used as the master
# Qleverfile and by having it here, we avoid having two files). The second
# Makefile is the Qleverfile in this directory
# 
# First show the command before executing it (make -n).
for ARG in "$@"; do
  echo "${BOLD}Executing \"${ARG}\":${NORMAL}"
  echo
  qlever_make_show "${ARG}"
  echo
  # Special precautions if index exists.
  # if [ "${ARG}" == "index" ]; then
  qlever_make "${ARG}"
  echo
done

eval ${EXIT}

# Everything after __DATA__ is the master Qleverfile

__DATA__
SHELL=/bin/bash
.DEFAULT_GOAL=show-config

# PIN WARMUP QUERIES TO CACHE (for the QLever UI)
# (c) Algorithms and Data Structures, University of Freiburg
# Originally written by Hannah Bast, 20.02.2021

# This Makefile provides the following targets:
#
# pin: Pin queries to cache, so that all autocompletion queries are fast, even
#      when "Clear cache" is clicked in the QLever UI (ther results for pinned 
#      queries will never be removed, unless ... see target clear).
#
# clear: Clear the cache completely (including pinned results). Note that this
#        can NOT be activated from the QLever UI.
#
# clear-unpinned: Clear all unpinned results from the cache. This is exactly
#                 what happens when clicking "Clear cache" in the QLever UI.
#
# show-all-ac-queries: Show the AC queries for subject, predicat, object for
#                      copy&paste in the QLever UI backend settings.

# This Makefile should be used as follows:
#
# 1. In the directors with the particular index, create a new Makefile
# 2. At the top add: include /local/data/qlever/qlever-indices/Makefile
#    (or wherever this Makefile - the master Makefile - resides)
# 3. Redefine API and FREQUENT_PREDICATES (see below) in the local Makefile
# 4. Redefine any of the patterns in the local Makefile
#    (the patterns below give a default functionality, which should work
#    for any knowledge base, but only using the raw IRIs, and no names,
#    aliases, or whatever special data the knowledge base has to offer.

# A prefix that identifies a particular build. This typically consists of a base
# name and optionally further specificataion separated by dots. For example:
# wikidata. Or: wikidata.2021-06-27
DB=

# The base name of the prefix=the part before the first dot. Often, the name
# of the input (ttl) file or of the settings (json) file use only the basename
# and not the full prefix.
DB_BASE=$(firstword $(subst ., ,$(DB)))

# The port of the QLever backend.
PORT=

# The slug used in the URL of the QLever API and the QleverUI API. This is
# typically the basename of the prefix. For example: wikidata. Or: freebase.
SLUG=$(DB_BASE)

# Memory for queries and for the cache (all in GB).
MEMORY_FOR_QUERIES=30
CACHE_MAX_SIZE_GB=30
CACHE_MAX_SIZE_GB_SINGLE_ENTRY=5
CACHE_MAX_NUM_ENTRIES=1000

# The local API of the server.
SERVER_API=http://localhost:$(PORT)

# The URL of the QLever backend.
QLEVER_API=https://qlever.cs.uni-freiburg.de/api/$(SLUG)

# The URL of the QLever UI istance ... TODO: it's confusing that this also has
# /api/ in the name, it actually has nothing to do with the URLs from the QLever
# backends (which are defined in the Apache configuration of QLever).
WARMUP_API=$(subst /api/,/api/warmup/,$(QLEVER_API))

# Admin token
TOKEN=aof4Ad

# Frequent predicates that should be pinned to the cache (can be left empty).
# Separate by space. You can use all the prefixes from PREFIXES (e.g. wdt:P31 if
# PREFIXES defines the prefix for wdt), but you can also write full IRIs. Just
# see how it is used in target pin: below, it's very simple.
FREQUENT_PREDICATES =
FREQUENT_PATTERNS_WITHOUT_ORDER =

# Directory with the QLever binaries.
QLEVER_BIN_DIR=/local/data/qlever/qlever-code/build

# Docker-related variables.
USE_DOCKER =
DOCKER_IMAGE=adfreiburg/qlever:latest
DOCKER_CONTAINER=qlever.$(DB)

# Configuration for SPARQL+Text.
QLEVER_TOOL_DIR=$(dir $(lastword $(MAKEFILE_LIST)))misc
WITH_TEXT =
TEXT_OPTIONS_INDEX=$(if $(WITH_TEXT),-w $(DB).wordsfile.tsv -d $(DB).docsfile.tsv,)
TEXT_OPTIONS_START=$(if $(WITH_TEXT),-t,)

show-config-default:
	@ echo "Basic configuration variables:"
	@ echo -e "\033[34m"
	@ for VAR in DB SLUG RDF_FILES CAT_FILES PORT \
	   MEMORY_FOR_QUERIES CACHE_MAX_SIZE_GB CACHE_MAX_SIZE_GB_SINGLE_ENTRY CACHE_MAX_NUM_ENTRIES \
	   TEXT_OPTIONS_INDEX TEXT_OPTIONS_START \
	   QLEVER_BIN_DIR USE_DOCKER DOCKER_IMAGE DOCKER_CONTAINER; do \
	   printf "%-30s = %s\n" "$$VAR" "$${!VAR}"; done
	@ echo -e "\033[0m"
	@ # echo "make index will do the following (but NOT if an index with that name exists):"
	@ # echo
	@ # $(MAKE) -sn index | egrep -v "^(if|fi)"
	@ # echo

%: %-default
	@ true

# Pull new image if image name contains a /

docker_pull:
	@ if [[ "$(DOCKER_IMAGE)" == */* ]]; then docker pull $(DOCKER_IMAGE); fi
	@ docker images -f "reference=$(DOCKER_IMAGE)"

# Produce list of all input files.
rdf-files:
	ls $(RDF_FILES)

# Produce the input as fed to the index builder.
cat-files:
	eval $(CAT_FILES)

# Building an index.
QLEVER_INDEX_CMD=IndexBuilderMain
QLEVER_INDEX_OPTIONS=-F ttl -f - -l -i $(DB) $(TEXT_OPTIONS_INDEX) -s $(DB_BASE).settings.json
index:
	if ls $(DB).index.* 1> /dev/null 2>&1; then #\
	  echo -e "\033[31mIndex exists, delete it first with \"qlever remove_index\" (add \"show\" to find out what gets deleted)\033[0m"; else #\
          time ($(CAT_FILES) | $(QLEVER_INDEX_CMD) $(QLEVER_INDEX_OPTIONS) | tee $(DB).index.log.txt) \
	; fi #

# Removing an index.
remove_index:
	rm -f $(DB).index.* $(DB).vocabulary.* $(DB).prefixes $(DB).meta-data.json $(DB).index-log.txt
	echo "The index files have been removed." #


# Starting the server in the background. If it is still runing, issue a warning
# and don't start it. Note the # after the code that does this check -> it will
# hence not be shown by qlever_make_show.
QLEVER_START_CMD=ServerMain -i $(DB)
QLEVER_START_OPTIONS=-j 8 -m $(MEMORY_FOR_QUERIES) -c $(CACHE_MAX_SIZE_GB) -e $(CACHE_MAX_SIZE_GB_SINGLE_ENTRY) -k $(CACHE_MAX_NUM_ENTRIES) -p $(PORT) $(TEXT_OPTIONS_START)
LOG_CMD=tail -f -n 10 $(DB).server-log.txt
start:
	if [ $$(curl --silent http://localhost:$(PORT) > /dev/null; echo $$?) == 0 ]; then #\
	  echo -e "\033[31mServer already running, to restart it first do \"stop\"\033[0m"; else #\
	echo "Starting the QLever server in the background and waiting till it's ready (Ctrl+C will not kill it) ..." && echo #\
	$(QLEVER_START_CMD) $(QLEVER_START_OPTIONS) > $(DB).server-log.txt & \
	$(LOG_CMD) & PID=$$!; while [ $$(curl --silent http://localhost:$(PORT) > /dev/null; echo $$?) != 0 ]; #\
	   do sleep 1; done; kill $${PID}; fi #

# Command line for showing the log and following it.
log:
	echo "Showing the log (abort with Ctrl+C) ..." #
	echo #
	$(LOG_CMD)

# Command line for stopping the server.
STOP_CMD_NATIVE=$$(while read PID; do kill $$PID 2> /dev/null; sed -i "/^$$PID$$/d" $(DB).pid; done < $(DB).pid)
STOP_CMD_DOCKER=docker stop $(DOCKER_CONTAINER)
STOP_CMD=$(if $(USE_DOCKER),$(STOP_CMD_DOCKER),$(STOP_CMD_NATIVE))
stop:
	echo "Stop the QLever server (find and kill manually if it fails) ..." #
	PS=$$(ps -ef | \grep "$(QLEVER_START_CMD)" | \grep -v "grep.*$(QLEVER_START_CMD)" | tr -s " ") && PID=$$(echo $${PS} | cut -d " " -f 2) && if [ -z "$${PID}" ]; then false; else kill "$${PID}"; fi \
	  && echo && echo -e "\033[34m$${PS}\033[0m" && echo && echo "Killed process with PID $${PID}" || #\
	  (echo && echo -e "\033[31mDid not find a running server or could not kill it\033[0m") #

wait:
	$(LOG_CMD) & PID=$$!; \
	 while [ $$(curl --silent http://localhost:$(PORT) > /dev/null; echo $$?) != 0 ]; \
	   do sleep 1; done; kill $$PID


# Create wordsfile and docsfile from all literals of the given NT file.
# Using this as input for a SPARQL+Text index build will effectively enable
# keyword search in literals. To understand how, look at the wordsfile and
# docsfile produced. See git:ad-freiburg/qlever/docs/sparql_and_text.md .
#
# TODO: Enable again, but need a checkout of the QLever repo.
#
# text_input_from_nt_literals:
#	python3 $(QLEVER_TOOL_DIR)/words-and-docs-file-from-nt.py $(DB)

# Warmup queries for the autocompletion.
# 
# TODO: This requires a running QLever UI and his currently hard-coded to use
# instances on particular machine (galera.informatik.privat). It will be fixed
# soon.
#
# NOTE: We need -tt here because the "qlever" script calls "make" via a pipe and
# so it does not have a terminal (the error message is "Pseudo-terminal will not
# be allocated because stdin is not a terminal." and "the input device is not a
# TTY"). The manpage for ssh says: "Multiple -t options force tty allocation,
# even if ssh has no local tty." and "-tt" is just a shorthand for "-t -t".
autocompletion-warmup:
	@ ssh -tt galera docker exec -it qlever-ui bash -c \"python manage.py warmup $(SLUG) pin\"

# pin.local:
# 	docker exec -it qlever-ui bash -c "python manage.py warmup $(SLUG) pin"
# 
# clear.local:
# 	docker exec -it qlever-ui bash -c "python manage.py warmup $(SLUG) clear"
# 
# clear_unpinned.local:
# 	docker exec -it qlever-ui bash -c "python manage.py warmup $(SLUG) clear_unpinned"

# Clear the cache.

clear-cache:
	echo "Clearing the cache (unpinned entries only) ..." #
	curl -Gs $(SERVER_API) --data-urlencode "cmd=clear-cache" > /dev/null
	curl -Gs $(SERVER_API) --data-urlencode "cmd=cache-stats" \
	  | sed 's/[{}",]//g; s/:/: /g; s/^\s\+//' | tr -s " " | numfmt --field=2,5,8,11,14 --grouping #

clear-cache-complete:
	echo "Clearing the cache completely (including pinned entries) ..." #
	curl -Gs $(SERVER_API) --data-urlencode "cmd=clear-cache-complete" > /dev/null
	curl -Gs $(SERVER_API) --data-urlencode "cmd=cache-stats" \
	  | sed 's/[{}",]//g; s/:/: /g; s/^\s\+//' | tr -s " " | numfmt --field=2,5,8,11,14 --grouping #

# Get various settings and statistics.

disk-usage:
	echo "Disk usage of all files in this QLever index, and the size of the input files" && echo #
	du -hc $(DB).index.[ops]* $(DB).vocabulary.* $(DB).prefixes $(DB).meta-data.json
	echo #
	# echo && echo "For comparison, the size of the input files" && echo #
	du -hc $(RDF_FILES)

cache-stats:
	echo "Show cache statistics (in number of IDs, an ID has 8 bytes) ..." #
	curl -Gs $(SERVER_API) --data-urlencode "cmd=cache-stats" \
	  | sed 's/[{}",]//g; s/:/: /g; s/^\s\+//' | tr -s " " | numfmt --field=2,5,8,11,14 --grouping #

memory-usage:
	@echo && docker stats --no-stream --format \
	  "Memory usage of docker container $(DOCKER_CONTAINER): {{.MemUsage}}" $(DOCKER_CONTAINER)

server-settings:
	echo "Getting settings from \"${SERVER_API}\" ..." #
	curl -Gs $(SERVER_API) --data-urlencode "cmd=get-settings" \
	  | sed 's/[{}",]//g; s/:/: /g; s/^\s\+//' | tr -s " " #
	
export
