#!/bin/bash

# This is the script that is called when calling "qlever" from the command line.
# It essentially calls "make", using the "Qleverfile" in the QLever home and in
# the current directory as Makefiles.
#
# Â© 2022, University of Freiburg, Chair of Algorithms and Data Structures
# Author: Hannah Bast <bast@cs.uni-freiburg.de>

BLUE=$(printf "\033[34m")
RED=$(printf "\033[31m")
GRAY=$(printf "\033[37m")
BOLD=$(printf "\033[1m")
NORMAL=$(printf "\033[0m")

###
### HELP (the help text shown with "qlever help")
###

function qlever_help {
  cat << EOT
${BOLD}QLever help${NORMAL}

The "qlever" script controls ALL things concerning QLever. Before using it the
first time in a particular shell and directory, type ". qlever". This will
enable autocompletion for the command line and create a basic Qleverfile (the
file containing all the configuration for QLever).

SETTINGS: When you call the script without arguments, you get an overview over
the basic settings. This list is not complete, there are more settings. If you
don't find something in the documentation, you can also just look in the script,
it's a bash script with a Makefile appended and so humand-readable (well, for
some humans).

ACTIONS: The autocompletion shows you the available actions. You can also
execute several actions with one command, for example "qlever index start log".
If you just want to see what an action does, but not exeute it, append show.
That you can also do for multiple actions, for example "qlever index start log
show".

BINARIES: You have two options for building and using the QLever binaries. You
can either use them via "docker" (via prebuilt images or your own images) or
"native"ly on your machine (then you have to do some installation first). The
default mode is "docker". Then all you need is a docker installation. The qlever
script will automatically download and run the right images for you.

[The last three sentences are not yet true. You currently need the QLever
binaries "IndexBuilderMain" and "ServerMain" on your machine and in your PATH.]

EOT
}



###
### PREAMBLE (basic variables and functions needed throughout)
###

# The command of this sript, as called (with relative,  absolute, or no path).
QLEVER_CMD="${BASH_SOURCE[0]}"

# Get the absolute path of QLEVER_CMD (assuming it's not a symbolic link). Note:
# the trick is to just "cd" there and then use "pwd", all in a subshell. For a
# hack that also works for symbolic links, see https://tinyurl.com/4jsurr86 .
QLEVER_CMD_DIR=$(cd -- "$(dirname -- "${QLEVER_CMD}")" &> /dev/null && pwd)

# To get the directory from where this script has been called, we can simply use
# "pwd".
APP_DIR=$(pwd)

# Get the master Qleverfile (everything after __DATA__ in this file, see below).
function get_master_qleverfile {
  # sed -e '1,/^__DATA__/d' ${QLEVER_CMD}
  sed -e '1,/^__DATA__/d' ${QLEVER_CMD} | tee Qleverfile.master.debug
}

# Variant of make that reads the master Qleverfile (using GET_MASTER_QLEVERFILE)
# and the local Qleverfile (in the directory from which this script is called).
# The -s option stands for "silent" (do not show the commands while executing
# them).
function qlever_make {
  get_master_qleverfile \
      | make -s -f - -f ${APP_DIR}/Qleverfile "$@" #2> /dev/null
}

# Like the above, but only show what would be executed (using the -n option of
# "make"), in blue. Leave out command lines that end with #.
function qlever_make_show {
  printf "${BLUE}"
  get_master_qleverfile \
      | make -f - -f ${APP_DIR}/Qleverfile -n "$@" \
      | egrep -v "#.?\$" | sed 's/^\s*//; s/\s?*\\$//' \
      | sed 's/^: #/#/'
  printf "${NORMAL}"
}

# Command to leave the script ("return" when the script is sourced, "exit" when
# it is called normally, that is, within its own subshell).
EXIT=exit
if [ ${QLEVER_CMD} != $0 ]; then EXIT=return; fi
function exit_qlever { eval ${EXIT}; }

# Where the QLever UI is found (on GitHub and locally).
QLEVERUI_GIT="git@github.com:ad-freiburg/qlever-ui.git"
QLEVERUI_DIR="qlever-ui"
# QLEVERUI_DIR="${APP_DIR}/qlever-ui"
QLEVERUI_DOCKER_IMAGE="qlever-ui"

# echo
# echo "${GRAY}Called \"${QLEVER_CMD}\" from \"${APP_DIR}\"${NORMAL}"
# echo
INTRO_MSG="This is the \"qlever\" script, type \"qlever help\" if you need help :-)"
# if [ ! -z "$*" ]; then
#   INTRO_MSG="${INTRO_MSG} When called without arguments, it will show you some basic settings."
# fi
if [ "$*" != "help" ]; then
  echo
  echo "${GRAY}${INTRO_MSG}${NORMAL}" | fold -s
fi
echo



###
### CONFIGURATION (called with . qlever)
###

COMPLETIONS_FILE=qlever.completions

# If not called with ". qlever" and completions are missing, tell the user to
# run ".  qlever" once for full functionality. Note that bash autocompletion can
# only be activated by "sourcing" the respective commands (the ". qlever" is
# equivalent to "source qlever").
if [ ${BASH_SOURCE[0]} == $0 ] && [ ! -e ${COMPLETIONS_FILE} ]; then
  cat << EOT
It seems you are running this script for the first time in this shell and
directory. Please run it once as follows:

${BLUE}. qlever${NORMAL}

Afterwards you can just call "qlever" again (without the dot), and you will have
bash autocompletion available. If you don't care about bash autocompletion or
something doesn't work, just create an empty file ${COMPLETIONS_FILE} before
your proceed.
    
EOT
    eval ${EXIT}
fi

# If called with ". qlever", setup what is not already setup: the PATH, the
# QLeverfile, the bash autocompletion.
if [ "${QLEVER_CMD}" != "$0" ]; then

  # PATH: Check if QLEVER_CMD_DIR is in the path and if not add it to the path.
  echo "${BOLD}Checking your PATH ...${NORMAL}"
  echo
  if [[ ":${PATH}:" == *":${QLEVER_CMD_DIR}:"* ]]; then
    echo "All fine, \"${QLEVER_CMD_DIR}\" is contained in your PATH."
  else
    export PATH=${PATH}:${QLEVER_CMD_DIR}
    cat << EOT | tr '\n' '  ' | fold -s
Added "${QLEVER_CMD_DIR}" to your PATH, so that you can just type "qlever" from
now on (without writing out the full path to it).
EOT
    echo
    # echo "${BLUE}${PATH}${NORMAL}"
  fi
  echo

  # QLeverfile: If it's not there yet, create a basic one (with good guesses for
  # some basic settings). Never overwrite an existing one, also not when called
  # with ". qlever reset".
  if [ -e Qleverfile ]; then
    if [ "$*" == "reset" ]; then
      echo "${BOLD}Redoing setup ...${NORMAL}"
      echo
      cat << EOT
There is alreay a QLeverfile in this directory. If you want a freshly generated
basic Qleverfile, remove or move the existing one and run ".  qlever reset"
again.

EOT
    fi
  else
    echo "${BOLD}Creating new Qleverfile ...${NORMAL}"
    echo
    # If a file with suffix .ttl or .nt exists, use the basename as the basename
    # for the index files (the DB variable in the configuration). If several such
    # files exist, take the largest one. If no such file exists, leave the
    # basename empty and for the user to set.
    INPUT_FILE=$(ls -S | egrep "\.(ttl|nt)(\.(gz|bz|bz2|xz))?\$" | head -1)
    if [ ! -z ${INPUT_FILE} ]; then DB=${INPUT_FILE/.*/}; else DB=; fi
      # Get right version of "cat", depending on suffix.
      CAT=cat
      if [[ ${INPUT_FILE} =~ \.gz\$ ]]; then CAT=zcat; fi
      if [[ ${INPUT_FILE} =~ \.bz\$ ]]; then CAT=bzcat; fi
      if [[ ${INPUT_FILE} =~ \.bz2\$ ]]; then CAT=bzca; fi
      if [[ ${INPUT_FILE} =~ \.xz\$ ]]; then CAT=xzca; fi
      cat << EOT > Qleverfile
# Qleverfile for folder $(pwd)
# Created on $(date).
# Modify or expand as you see fit.

DB              = ${DB}
RDF_FILES       = ${INPUT_FILE}
CAT_FILES       = ${CAT} \$(RDF_FILES)

HOSTNAME        = $(hostname -f)
SERVER_PORT     = 7001
QLEVERUI_PORT   = 7000
QLEVERUI_DIR    = ${QLEVERUI_DIR}
QLEVERUI_CONFIG = ${DB}

MEMORY_FOR_QUERIES             = 10
CACHE_MAX_SIZE_GB              = 5
CACHE_MAX_SIZE_GB_SINGLE_ENTRY = 1
CACHE_MAX_NUM_ENTRIES          = 100
EOT
      cat << EOT
There was no Qleverfile in this directory yet. A Qleverfile contains
basic configuration telling the "qlever" command how to do certain
things. The following basic Qleverfile was now created:

${BLUE}$(cat Qleverfile)${NORMAL}

EOT
  fi

  # Bash autocompletion: If there is no COMPLETIONS_FILE yet or if called with
  # argument "reset", create it and activate the autocompletion (only has an
  # effect outside of this script when called with ". qlever").
  if [ ! -e ${COMPLETIONS_FILE} ] || [ "$*" == "reset" ]; then
    echo "${BOLD}Setting up bash autocompletion ...${NORMAL}"
    echo
    COMPLETIONS=$(get_master_qleverfile | \grep -oE "^[a-zA-Z_.-]+:" | sed 's/:$//' | paste -sd" ")
    echo "${COMPLETIONS}" > ${COMPLETIONS_FILE}
    complete -W "${COMPLETIONS}" qlever
    echo "Done, the following completions are now available:"
    echo
    echo "${BLUE}$(fold -s  ${COMPLETIONS_FILE})${NORMAL}"
    echo
  fi

  # QLever UI: if the repo is not there yet, download it via GitHub.
  #
  # TODO: For now, just have a working copy for each QLever instance. One central
  # working copy would be also fine, but it also doesn't hurt because it's less
  # than 50 MB large.
  if [ ! -d ${QLEVERUI_DIR} ]; then
    cat << EOT
${BOLD}Downloading and building QLever UI ...${NORMAL}

Downloading a copy from ${QLEVERUI_GIT} (it's small) and building the docker
image from it. This requires that you have docker installed. Stay tuned if you
want to use the QLever UI without docker. Also, if you just want to interact
with a QLever server via API, you don't need the QLever UI.
EOT
    echo && echo
    git clone ${QLEVERUI_GIT} ${QLEVERUI_DIR}
    echo 
    # QLEVERUI_BUILD_LOG="qleverui.build-log.txt"
    # echo "Building docker image \"${QLEVERUI_DOCKER_IMAGE}\", log in \"${QLEVERUI_BUILD_LOG}\" ..."
    # echo
    # (cd ${QLEVERUI_DIR} && docker build -t ${QLEVERUI_DOCKER_IMAGE} . \
    #     | > qleverui.build-log.txt)
  fi

  # DONE: give the user a short heads up what they can do now.
  cat << EOT
${BOLD}Setup is complete${NORMAL}

Type "qlever" and use autocompletion to see which actions are available. Add a
"show" in the end to see what an action does without executing it (for example,
"qlever index show"). Typing "qlever" without arguments gives you overview over
the basic configuration. Edit your local "Qleverfile" to change settings.

If you want to redo the setup, you can run ".  qlever reset" anytime.

EOT
  eval ${EXIT}
fi


#   cat << EOT | tr '\n' ' ' | fold -s
#     ${BOLD}Resetting configuration${NORMAL}
#     
#     Regenerating the completions. The QLeverfile is not regenerated. If you want to
#     regenerate it, remove it and run ". qlever reset" again.
# 
# EOT
#   complete -r qlever 2> /dev/null
#   rm -f qlever.completions




###
### WHAT THE SCRIPT ACTUALLY DOES (it's basically a wrapper for "make")
###
 
# First separate the variable assignment arguments from the others. The
# assignment will go in VARS, the rest will stay in $@ (both arrays).
VARS=( "QLEVER_CMD=${QLEVER_CMD}" "QLEVER_CMD_DIR=${QLEVER_CMD_DIR}" )
for ARG do
  shift
  [[ "${ARG}" =~ ^[A-Z_]+= ]] && VARS+=( "${ARG}" ) && continue
  set -- "$@" "${ARG}"
done
# for VAR in "${VARS[@]}"; do echo "VAR = \"${VAR}\""; done
# for ARG in "$@"; do echo "ARG = \"${ARG}\""; done
# echo

# When calling script with no arguments, show the config. TODO: Give the user
# some more information here.
if [ -z "$*" ]; then
  qlever_make "${VARS[@]}"
  if [ -e ${COMPLETIONS_FILE} ]; then
    cat << EOT
All completions:

${BLUE}$(cat ${COMPLETIONS_FILE} | fold -s)${NORMAL}

To see what a particular command would do (without executing it), just type
something like "qlever index show" (single command) or "qlever start log show"
(multiple commands)

EOT
  fi
  eval ${EXIT}
fi

# When the only action is "help", show help info.
if [ "$*" == "help" ]; then
  qlever_help
  eval ${EXIT}
fi



# If the last argument is "show", just show the commands, but don't execute
# them. The first for loop is a portable hack to get the last argument.
for LAST; do true; done
if [ "${LAST}" == "show" ]; then
  echo "${BOLD}Just showing what would be executed${NORMAL}"
  echo
  for ARG in "$@"; do
    if [ "${ARG}" != "show" ]; then
      echo "\"${ARG}\" would execute the following:"
      echo
      qlever_make_show "${VARS[@]}" "${ARG}"
      echo
    fi
  done
  eval ${EXIT}
fi

# Normal execution of script using make with two Makefiles. The first Makefile
# is everything after __DATA__ below (that part is used as the master
# Qleverfile and by having it here, we avoid having two files). The second
# Makefile is the Qleverfile in this directory
# 
# First show the command before executing it (make -n).
for ARG in "$@"; do
  echo "${BOLD}Executing \"${ARG}\":${NORMAL}"
  echo
  # TODO: Handle non-existing commands more gracefully, currently an error
  # message from "make" is shown (twice).
  if qlever_make_show "${VARS[@]}" "${ARG}" ; then
    echo
    qlever_make "${VARS[@]}" "${ARG}"
  fi
  echo
done

eval ${EXIT}



###
### The master Qleverfile = Makefile (everything after __DATA__)
###

__DATA__
SHELL=/bin/bash
.DEFAULT_GOAL=show-config

# PIN WARMUP QUERIES TO CACHE (for the QLever UI)
# (c) Algorithms and Data Structures, University of Freiburg
# Originally written by Hannah Bast, 20.02.2021

# This Makefile provides the following targets:
#
# pin: Pin queries to cache, so that all autocompletion queries are fast, even
#      when "Clear cache" is clicked in the QLever UI (ther results for pinned 
#      queries will never be removed, unless ... see target clear).
#
# clear: Clear the cache completely (including pinned results). Note that this
#        can NOT be activated from the QLever UI.
#
# clear-unpinned: Clear all unpinned results from the cache. This is exactly
#                 what happens when clicking "Clear cache" in the QLever UI.
#
# show-all-ac-queries: Show the AC queries for subject, predicat, object for
#                      copy&paste in the QLever UI backend settings.

# This Makefile should be used as follows:
#
# 1. In the directors with the particular index, create a new Makefile
# 2. At the top add: include /local/data/qlever/qlever-indices/Makefile
#    (or wherever this Makefile - the master Makefile - resides)
# 3. Redefine API and FREQUENT_PREDICATES (see below) in the local Makefile
# 4. Redefine any of the patterns in the local Makefile
#    (the patterns below give a default functionality, which should work
#    for any knowledge base, but only using the raw IRIs, and no names,
#    aliases, or whatever special data the knowledge base has to offer.

# A prefix that identifies a particular build. This typically consists of a base
# name and optionally further specificataion separated by dots. For example:
# wikidata. Or: wikidata.2021-06-27
DB=

# The base name of the prefix=the part before the first dot. Often, the name
# of the input (ttl) file or of the settings (json) file use only the basename
# and not the full prefix.
DB_BASE=$(firstword $(subst ., ,$(DB)))

# The port of the QLever backend.
HOSTNAME=must_specify
SERVER_PORT=must_specify

# The port of QLever UI.
QLEVERUI_PORT=7000

# The slug used in the URL of the QLever API and the QleverUI API. This is
# typically the basename of the prefix. For example: wikidata. Or: freebase.
SLUG=$(DB_BASE)

# Memory for queries and for the cache (all in GB).
MEMORY_FOR_QUERIES=30
CACHE_MAX_SIZE_GB=30
CACHE_MAX_SIZE_GB_SINGLE_ENTRY=5
CACHE_MAX_NUM_ENTRIES=1000

# The local API of the server.
SERVER_API=http://$(HOSTNAME):$(SERVER_PORT)

# The URL of the QLever backend.
QLEVER_API=https://qlever.cs.uni-freiburg.de/api/$(SLUG)

# The URL of the QLever UI istance ... TODO: it's confusing that this also has
# /api/ in the name, it actually has nothing to do with the URLs from the QLever
# backends (which are defined in the Apache configuration of QLever).
WARMUP_API=$(subst /api/,/api/warmup/,$(QLEVER_API))

# Admin token
TOKEN=aof4Ad

# Frequent predicates that should be pinned to the cache (can be left empty).
# Separate by space. You can use all the prefixes from PREFIXES (e.g. wdt:P31 if
# PREFIXES defines the prefix for wdt), but you can also write full IRIs. Just
# see how it is used in target pin: below, it's very simple.
FREQUENT_PREDICATES =
FREQUENT_PATTERNS_WITHOUT_ORDER =

# Directory with the QLever binaries.
QLEVER_BIN_DIR=/local/data/qlever/qlever-code/build

# Docker-related variables.
USE_DOCKER =
DOCKER_IMAGE=adfreiburg/qlever:latest
DOCKER_CONTAINER=qlever.$(DB)

# Configuration for SPARQL+Text.
QLEVER_TOOL_DIR=$(dir $(lastword $(MAKEFILE_LIST)))misc
WITH_TEXT=

# Activate text options iff WITH_TEXT is one of: true yes 1. Don't forget the
# leading whitespace because this is appended to the other options.
WITH_TEXT_EMPTY_IF_FALSE=$(findstring $(WITH_TEXT),true yes 1)
TEXT_OPTIONS_INDEX=$(if $(WITH_TEXT_EMPTY_IF_FALSE), -w $(DB).wordsfile.tsv -d $(DB).docsfile.tsv,)
TEXT_OPTIONS_START=$(if $(WITH_TEXT_EMPTY_IF_FALSE), -t,)

show-config:
	echo "Basic configuration variables:"
	echo -e "\033[34m"
	for VAR in DB SLUG RDF_FILES CAT_FILES WITH_TEXT SERVER_PORT  \
	 MEMORY_FOR_QUERIES CACHE_MAX_SIZE_GB CACHE_MAX_SIZE_GB_SINGLE_ENTRY CACHE_MAX_NUM_ENTRIES \
	 QLEVER_BIN_DIR USE_DOCKER DOCKER_IMAGE DOCKER_CONTAINER; do \
	 printf "%-30s = %s\n" "$$VAR" "$${!VAR}"; done
	echo -e "\033[0m"

# Update the qlever script (locate, check whether it's a git working copy, git
# pull). Note: When this is called by the qlever script, QLEVER_CMD and
# QLEVER_CMD_DIR are from there via VARS.
# TODO: Is the method via VARS sufficiently generic or is there a better way?
QLEVER_CMD=
QLEVER_CMD_DIR=
update:
	echo "Updating \"qlever\" script ..." #
	echo #
	if [ ! -d "$(QLEVER_CMD_DIR)/.git" ]; then #\
	  echo -e "\033[31mDid not find directory \".git\" in \"${QLEVER_CMD_DIR}\"\033[0m" #\
	  echo; fi #\
	cd $(QLEVER_CMD_DIR) && git pull

where:
	echo "The absolute path of the directory where the \"qlever\" script is located..." #
	echo -e "\033[34m" #
	cd -- "$$(dirname -- "$(QLEVER_CMD)")" &> /dev/null && pwd
	printf "\033[0m" #

# Pull new image if image name contains a /

docker_pull:
	@ if [[ "$(DOCKER_IMAGE)" == */* ]]; then docker pull $(DOCKER_IMAGE); fi
	@ docker images -f "reference=$(DOCKER_IMAGE)"

# Produce list of all input files.
rdf-files:
	ls $(RDF_FILES)

# Produce the input as fed to the index builder.
cat-files:
	eval $(CAT_FILES)

# Building an index.
QLEVER_INDEX_CMD=IndexBuilderMain
QLEVER_INDEX_OPTIONS=-F ttl -f - -l -i $(DB) $(TEXT_OPTIONS_INDEX) -s $(DB_BASE).settings.json
index:
	if ls $(DB).index.* 1> /dev/null 2>&1; then #\
	  echo -e "\033[31mIndex exists, delete it first with \"qlever remove_index\" (add \"show\" to find out what gets deleted)\033[0m"; else #\
          time ($(CAT_FILES) | $(QLEVER_INDEX_CMD) $(QLEVER_INDEX_OPTIONS) | tee $(DB).index.log.txt) \
	; fi #

# Removing an index.
remove_index:
	rm -f $(DB).index.* $(DB).vocabulary.* $(DB).prefixes $(DB).meta-data.json $(DB).index-log.txt
	echo "The index files have been removed." #


# Starting the server in the background. If it is still runing, issue a warning
# and don't start it. Note the # after the code that does this check -> it will
# hence not be shown by qlever_make_show.
QLEVER_START_CMD=ServerMain
QLEVER_START_OPTIONS=-i $(DB) -j 8 -m $(MEMORY_FOR_QUERIES) -c $(CACHE_MAX_SIZE_GB) -e $(CACHE_MAX_SIZE_GB_SINGLE_ENTRY) -k $(CACHE_MAX_NUM_ENTRIES) -p $(SERVER_PORT)$(TEXT_OPTIONS_START)
LOG_CMD=tail -f -n 10 $(DB).server-log.txt
start:
	if [ $$(curl --silent http://localhost:$(SERVER_PORT) > /dev/null; echo $$?) == 0 ]; then #\
	  echo -e "\033[31mServer already running on port ${SERVER_PORT}, to restart it first do \"stop\" (or check the PORT in your Qleverfile)\033[0m"; #\
	  echo -e "\033[34m"; #\
	  ps -e -o "%p" -o "  %U " -o start_time -o "  %a" | \grep "${QLEVER_START_CMD} .*-p ${SERVER_PORT}" | \grep -v "grep.*${QLEVER_START_CMD}"; #\
	  printf "\033[0m"; else #\
	  # echo && ps -ef | \grep "${QLEVER_START_CMD} .*-p ${SERVER_PORT}" | \grep -v "grep.*${QLEVER_START_CMD}" | tr -s " "; else #\
	echo "Starting the QLever server in the background and waiting till it's ready (Ctrl+C will not kill it) ..." && echo #\
	$(QLEVER_START_CMD) $(QLEVER_START_OPTIONS) > $(DB).server-log.txt & \
	$(LOG_CMD) & PID=$$!; while [ $$(curl --silent http://localhost:$(SERVER_PORT) > /dev/null; echo $$?) != 0 ]; #\
	   do sleep 1; done; kill $${PID}; fi #

# Command line for showing the log and following it.
log:
	echo "Showing the log (abort with Ctrl+C) ..." #
	echo #
	$(LOG_CMD)

# Command line for stopping the server. NOTE: This also pays attention that the
# index name fits.
STOP_CMD_NATIVE=$$(while read PID; do kill $$PID 2> /dev/null; sed -i "/^$$PID$$/d" $(DB).pid; done < $(DB).pid)
STOP_CMD_DOCKER=docker stop $(DOCKER_CONTAINER)
STOP_CMD=$(if $(USE_DOCKER),$(STOP_CMD_DOCKER),$(STOP_CMD_NATIVE))
stop:
	echo "Stop the QLever server (find and kill manually if it fails) ..." #
	PS=$$(ps -e -o "%p" -o "  %U " -o start_time -o "  %a" | \grep "$(QLEVER_START_CMD) -i [^ ]*$(DB)") && PID=$$(echo $${PS} | cut -d " " -f 1) && kill $${PID} \
	  2> /dev/null && echo && echo -e "\033[34m$${PS}\033[0m" && echo && echo "Killed process with PID $${PID}" || #\
          (echo && echo -e "\033[31mDid not find a running server for \"$(DB)\" or could not kill it, try \"qlever status\"\033[0m") #

status:
	echo "Showing all processes with command \"$(QLEVER_START_CMD)\" on this machine ..." #
	echo -e "\033[34m" #
	ps -e -o "%p" -o "  %U " -o start_time -o "  %a" | \grep "${QLEVER_START_CMD}" | \grep -v "grep.*${QLEVER_START_CMD}"
	printf "\033[0m" #

wait:
	$(LOG_CMD) & PID=$$!; \
	 while [ $$(curl --silent http://localhost:$(SERVER_PORT) > /dev/null; echo $$?) != 0 ]; \
	   do sleep 1; done; kill $$PID


# Create wordsfile and docsfile from all literals of the given NT file.
# Using this as input for a SPARQL+Text index build will effectively enable
# keyword search in literals. To understand how, look at the wordsfile and
# docsfile produced. See git:ad-freiburg/qlever/docs/sparql_and_text.md .
#
# TODO: Enable again, but need a checkout of the QLever repo.
#
# text_input_from_nt_literals:
#	python3 $(QLEVER_TOOL_DIR)/words-and-docs-file-from-nt.py $(DB)

# Warmup queries for the autocompletion.
# 
# TODO: This requires a running QLever UI and his currently hard-coded to use
# instances on particular machine (galera.informatik.privat). It will be fixed
# soon.
#
# NOTE: We need -tt here because the "qlever" script calls "make" via a pipe and
# so it does not have a terminal (the error message is "Pseudo-terminal will not
# be allocated because stdin is not a terminal." and "the input device is not a
# TTY"). The manpage for ssh says: "Multiple -t options force tty allocation,
# even if ssh has no local tty." and "-tt" is just a shorthand for "-t -t".in.master:
pin.INTERNAL:
	echo "Launch warmup queries for the QLever UI autocompletion (via galera) ..." #
	ssh -tt galera docker exec -it qlever-ui bash -c \"python manage.py warmup $(SLUG) pin\"

# pin.local:
# 	docker exec -it qlever-ui bash -c "python manage.py warmup $(SLUG) pin"
# 
# clear.local:
# 	docker exec -it qlever-ui bash -c "python manage.py warmup $(SLUG) clear"
# 
# clear_unpinned.local:
# 	docker exec -it qlever-ui bash -c "python manage.py warmup $(SLUG) clear_unpinned"

# Clear the cache.

clear-cache:
	echo "Clearing the cache (unpinned entries only) ..." #
	curl -Gs $(SERVER_API) --data-urlencode "cmd=clear-cache" > /dev/null
	curl -Gs $(SERVER_API) --data-urlencode "cmd=cache-stats" \
	  | sed 's/[{}",]//g; s/:/: /g; s/^\s\+//' | tr -s " " | numfmt --field=2,5,8,11,14 --grouping #

clear-cache-complete:
	echo "Clearing the cache completely (including pinned entries) ..." #
	curl -Gs $(SERVER_API) --data-urlencode "cmd=clear-cache-complete" > /dev/null
	curl -Gs $(SERVER_API) --data-urlencode "cmd=cache-stats" \
	  | sed 's/[{}",]//g; s/:/: /g; s/^\s\+//' | tr -s " " | numfmt --field=2,5,8,11,14 --grouping #

# Get various settings and statistics.

disk-usage:
	echo "Disk usage of all files in this QLever index, and the size of the input files" && echo #
	du -hc $(DB).index.[ops]* $(DB).vocabulary.* $(DB).prefixes $(DB).meta-data.json
	echo #
	# echo && echo "For comparison, the size of the input files" && echo #
	du -hc $(RDF_FILES)

cache-stats:
	echo "Show cache statistics (in number of IDs, an ID has 8 bytes) ..." #
	curl -Gs $(SERVER_API) --data-urlencode "cmd=cache-stats" \
	  | sed 's/[{}",]//g; s/:/: /g; s/^\s\+//' | tr -s " " | numfmt --field=2,5,8,11,14 --grouping #

memory-usage:
	@echo && docker stats --no-stream --format \
	  "Memory usage of docker container $(DOCKER_CONTAINER): {{.MemUsage}}" $(DOCKER_CONTAINER)

server-settings:
	echo "Getting settings from \"${SERVER_API}\" ..." #
	curl -Gs $(SERVER_API) --data-urlencode "cmd=get-settings" \
	  | sed 's/[{}",]//g; s/:/: /g; s/^\s\+//' | tr -s " " #

# QLever UI (work in progress).
LOG_FILE=qleverui-log.tmp
ERROR_CMD=(echo && echo -e "\033[31mAn error occured, check $(LOG_FILE) for details, the last 10 lines are:\033[0m" && tail $(LOG_FILE) && false)
QLEVERUI_GIT=git@github.com:ad-freiburg/qlever-ui.git
ui:
	> $(LOG_FILE) #
	# echo "Downloading QLever UI (unless it's already there) ..." #
	# if [ ! -d "$(QLEVERUI_DIR)" ]; then date && git clone "$(QLEVERUI_GIT)" "$(QLEVERUI_DIR)" && date; fi \ #
	#  >> $(LOG_FILE) 2>&1 || $(ERROR_CMD) #
	echo "Creating configuration for the QLever UI ..." #
	$(MAKE) -s -C "$(QLEVERUI_DIR)" CONFIG_SLUG=$(QLEVERUI_CONFIG) BACKEND_PORT=$(SERVER_PORT) overwrite_config \
	  >> $(LOG_FILE) 2>&1 || $(ERROR_CMD) #
	echo "Launching QLever UI web application ..." #
	$(MAKE) -s -C $(QLEVERUI_DIR) HOSTNAME=$(HOSTNAME) FRONTEND_PORT=$(QLEVERUI_PORT) qlever-ui \
	  >> $(LOG_FILE) 2>&1 || $(ERROR_CMD) #
	# echo "Warmup queries for fast autocompletion (check HOSTNAME and PORTs if something goes wrong here) ..." #
	# $(QLEVERUI_MAKE) -s CONFIG_SLUG=$(CONFIG_SLUG) QLEVERUI_CONTAINER=$(QLEVERUI_CONTAINER) warmup >> $(LOG_FILE) 2>&1 || $(ERROR_CMD) #
	echo #
	echo "Looks like it worked, go to http://$(HOSTNAME):$(QLEVERUI_PORT) and try out some queries. If it doesn't work, check \"$(LOG_FILE)\" for suspicious messages or \"$(QLEVERUI_DIR)/Makefile\" for troubleshooting help" | fold -s #
	# (MAKE) -s -C "${QLEVERUI_DIR}" FRONTEND_PORT=$(QLEVERUI_PORT) BACKEND_PORT=$(SERVER_PORT) CONFIG_SLUG=$(DB) #

autocompletion-warmup:
	echo "Launch warmup queries for the QLever UI autocompletion ..." #
	docker exec -i qlever-ui bash -c "python manage.py warmup $(QLEVERUI_CONFIG) pin" \
	  >> $(LOG_FILE) 2>&1 || $(ERROR_CMD) #
	
export
