#!/bin/bash

# This is the script that is called when calling "qlever" from the command line.
# It's a bash script that invokes "make" for the various actions, using the
# Makefile contained at the end of this script (after the special line __DATA__)
# and the "Qleverfile" in the directory from which the script is called.
#
# Â© 2022, University of Freiburg, Chair of Algorithms and Data Structures
# Author: Hannah Bast <bast@cs.uni-freiburg.de>

BLUE=$(printf "\033[34m")
RED=$(printf "\033[31m")
GRAY=$(printf "\033[37m")
MAGENTA=$(printf "\033[35m")
BOLD=$(printf "\033[1m")
NORMAL=$(printf "\033[0m")

###
### HELP (the help text shown with "qlever help")
###

function qlever_help {
  cat << EOT
${BOLD}QLever help${NORMAL}

The "qlever" script controls ALL things concerning QLever. Before using it the
first time in a particular shell and directory, type ". qlever". This will
enable autocompletion for the command line and create a basic Qleverfile.

QLEVERFILE: You need a file named "QLeverfile" in the directory from which you
are calling the "qlever" script. It controls settings of the script, the dataset
you want to process, the server, and the QLever UI. After the initial call to ".
qlever", the Qleverfile will contain default settings.

ACTIONS: The autocompletion shows you the available actions. You can also
execute several actions with one command, for example "qlever index start log".
If you just want to see what an action does, but not exeute it, append show.
That you can also do for multiple actions, for example "qlever index start log
show".

BINARIES: You have two options for building and using the QLever binaries. You
can either use them via "docker" (via prebuilt images or your own images) or
"native"ly on your machine (then you have to do some installation first). The
default mode is "docker". Then all you need is a docker installation. The qlever
script will automatically download and run the right images for you.

[The last three sentences are not yet true. You currently need the QLever
binaries "IndexBuilderMain" and "ServerMain" on your machine and in your PATH.]

EOT
}



###
### PREAMBLE (basic variables and functions needed throughout)
###

# The command of this sript, as called (with relative,  absolute, or no path).
QLEVER_CMD="${BASH_SOURCE[0]}"

# Get the absolute path of QLEVER_CMD (assuming it's not a symbolic link). Note:
# the trick is to just "cd" there and then use "pwd", all in a subshell. For a
# hack that also works for symbolic links, see https://tinyurl.com/4jsurr86 .
QLEVER_CMD_DIR=$(cd -- "$(dirname -- "${QLEVER_CMD}")" &> /dev/null && pwd)

# To get the directory from where this script has been called, we can simply use
# "pwd".
APP_DIR=$(pwd)

# Get the master Qleverfile (everything after __DATA__ in this file, see below).
function get_master_qleverfile {
  # sed -e '1,/^__DATA__/d' ${QLEVER_CMD}
  sed -e '1,/^__DATA__/d' ${QLEVER_CMD} | tee Qleverfile.master.debug
}

# Variant of make that reads the master Qleverfile (using GET_MASTER_QLEVERFILE)
# and the local Qleverfile (in the directory from which this script is called).
# The -s option stands for "silent" (do not show the commands while executing
# them).
function qlever_make {
  if [ -e "${APP_DIR}/Qleverfile" ]; then
    get_master_qleverfile \
        | make -s -f - -f ${APP_DIR}/Qleverfile "$@" #2> /dev/null
  else
    get_master_qleverfile | make -s -f - "$@"
  fi
}

# Like the above, but only show what would be executed (using the -n option of
# "make"), in blue. Leave out command lines that end with #.
function qlever_make_show {
  printf "${BLUE}"
  get_master_qleverfile \
      | make -f - -f ${APP_DIR}/Qleverfile -n "$@" \
      | egrep -v "#.?\$" | sed 's/^\s*//; s/\s?*\\$//' \
      | sed 's/^: #/#/'
  printf "${NORMAL}"
}

# Command to leave the script ("return" when the script is sourced, "exit" when
# it is called normally, that is, within its own subshell).
EXIT=exit
if [ ${QLEVER_CMD} != $0 ]; then EXIT=return; fi
function exit_qlever { eval ${EXIT}; }

# Where the QLever UI is found (on GitHub and locally).
QLEVERUI_GIT="git@github.com:ad-freiburg/qlever-ui.git"
QLEVERUI_DIR="qlever-ui"
# QLEVERUI_DIR="${APP_DIR}/qlever-ui"
QLEVERUI_DOCKER_IMAGE="qlever-ui"

# echo
# echo "${GRAY}Called \"${QLEVER_CMD}\" from \"${APP_DIR}\"${NORMAL}"
# echo
INTRO_MSG="This is the \"qlever\" script, type \"qlever help\" if you need help :-)"
# if [ ! -z "$*" ]; then
#   INTRO_MSG="${INTRO_MSG} When called without arguments, it will show you some basic settings."
# fi
if [ ! -z "$*" ] && [ "$*" != "help" ]; then
  echo
  echo "${GRAY}${INTRO_MSG}${NORMAL}" | fold -s
fi
echo



###
### CONFIGURATION (called with . qlever)
###

# Get selected variables from the master Qleverfile (and also the local
# Qleverfile if it exists).
eval $(qlever_make export.HIDDEN)
# echo "${MAGENTA}DEBUG: qlever_make export${NORMAL}"
# echo
# echo "BASH_COMPLETION = ${BASH_COMPLETION}"
# echo "USE_DOCKER = ${USE_DOCKER}"
# echo "QLEVER_COMPLETIONS=${QLEVER_COMPLETIONS}"
# echo

# If not called with ". qlever" and completions or the Qleverfile are missing,
# tell the user to run ". qlever" once for full functionality. Note that bash
# autocompletion can only be activated by "sourcing" the respective commands
# (the ". qlever" is equivalent to "source qlever"). If the Qleverfile has
# BASH_COMPLETION = 0, don't mind the autocompletion.
if [ ${BASH_SOURCE[0]} == $0 ] \
  && ( ( [ -z "${QLEVER_COMPLETIONS}" ] && [ "${BASH_COMPLETION}" != "0" ] ) || \
       [ ! -e Qleverfile ] ); then
    cat << EOT
Bash completion not activated or no Qleverfile exists or both. Please run the
qlever configuration once as follows (an existing Qleverfile will not be
overwritten, don't worry): 

${BLUE}. qlever${NORMAL}

Afterwards you can just call "qlever" (without the dot). If you don't care about
bash autocompletion or it doesn't work on your system, set BASH_COMPLETION = 0
in your Qleverfile.

EOT
    eval ${EXIT}
fi

# If called with ". qlever", setup what is not already setup: the PATH, the bash
# autocompletion (unless user don't want it), the QLeverfile.
if [ "${QLEVER_CMD}" != "$0" ]; then

  # PATH: Check if QLEVER_CMD_DIR is in the path and if not add it to the path.
  # ALso check if 
  echo "${BOLD}Checking your PATH ...${NORMAL}"
  echo
  if [[ ":${PATH}:" == *":${QLEVER_CMD_DIR}:"* ]]; then
    echo "All fine, \"${QLEVER_CMD_DIR}\" is contained in your PATH."
  else
    export PATH=${PATH}:${QLEVER_CMD_DIR}
    cat << EOT | tr '\n' '  ' | fold -s
Added "${QLEVER_CMD_DIR}" to your PATH, so that you can just type "qlever" from
now on (without writing out the full path to it).
EOT
    echo
    # echo "${BLUE}${PATH}${NORMAL}"
  fi
  echo

  # PATH 2: Same check for QLEVER_BINARIES_DIR (currently hard-coded, see its
  # definition above).
  if [[ ":${PATH}:" != *":${QLEVER_BIN_DIR}:"* ]]; then
    export PATH=${PATH}:${QLEVER_BIN_DIR}
  fi

  # If we called ". qlever path" (just to set the paths), exit here.
  if [ "$*" == "init" ]; then
    echo "${BOLD}Called \". qlever init\", so leaving now${NORMAL}"
    echo
    eval ${EXIT}
  fi

  # Bash autocompletion: Set completions with "complete -W" and store the
  # completions in "QLEVER_COMPLETIONS". We need the latter so that we know that
  # the completions are set (complete -p does not work in a subshell).
  COMPLETIONS_FILE=no_longer_needed
  echo "${BOLD}Setting up bash autocompletion ...${NORMAL}"
  echo
  COMPLETIONS=$(get_master_qleverfile | \grep -oE "^[a-zA-Z_.-]+:" \
    | \grep -v "\.HIDDEN:$" | sed 's/:$//' | paste -sd" ")
  export QLEVER_COMPLETIONS="${COMPLETIONS}"
  complete -W "${COMPLETIONS}" qlever
  eval ${COMPLETIONS_CMD}
  echo "Done, the following completions are now available:"
  echo
  echo "${BLUE}$(echo ${QLEVER_COMPLETIONS} | fold -s)${NORMAL}"
  echo

  # If we called ". qlever init" (for use in .bashrc, where we only want to set
  # the PATH and activate the autocompletion), exit here.
  if [ "$*" == "init" ]; then
    echo "${BOLD}Called \". qlever init\", so leaving now${NORMAL}"
    echo
    eval ${EXIT}
  fi

  # QLeverfile: If it's not there yet, create a basic one (with good guesses for
  # some basic settings). Never overwrite an existing one, also not when called
  # with ". qlever reset".
  if [ -e Qleverfile ]; then
    if [ "$*" == "reset" ]; then
      echo "${BOLD}Redoing setup ...${NORMAL}"
      echo
      cat << EOT
There is alreay a QLeverfile in this directory. If you want a freshly generated
basic Qleverfile, remove or move the existing one and run ".  qlever reset"
again.

EOT
    fi
  else
    echo "${BOLD}Creating new Qleverfile ...${NORMAL}"
    echo
    # If a file with suffix .ttl or .nt exists, use the basename as the basename
    # for the index files (the DB variable in the configuration) and pick the
    # right "cat" command according to the suffix. If several such files exist,
    # take the largest one. If no such file exists, leave the basename empty and
    # for the user to set.
    INPUT_FILE=$(ls -S | egrep "\.(ttl|nt)(\.(gz|bz|bz2|xz))?\$" | head -1)
    CAT=cat
    if [ ! -z ${INPUT_FILE} ]; then
      DB=${INPUT_FILE/.*/}
      if [[ ${INPUT_FILE} =~ \.gz\$ ]]; then CAT=zcat; fi
      if [[ ${INPUT_FILE} =~ \.bz\$ ]]; then CAT=bzcat; fi
      if [[ ${INPUT_FILE} =~ \.bz2\$ ]]; then CAT=bzca; fi
      if [[ ${INPUT_FILE} =~ \.xz\$ ]]; then CAT=xzca; fi
      QLEVERUI_CONFIG=${DB}
    else
      DB=must_specify
      INPUT_FILE=must_specifiy
      QLEVERUI_CONFIG=default
    fi
    cat << EOT > Qleverfile
# Qleverfile for folder $(pwd)
# Created on $(date).
# Modify or expand as you see fit.

# QLever actions
USE_DOCKER      = 1
BASH_COMPLETION = 1

# Dataset
DB              = ${DB}
RDF_FILES       = ${INPUT_FILE}
CAT_FILES       = ${CAT} \$(RDF_FILES)

# Server settings
HOSTNAME                       = $(hostname -f)
SERVER_PORT                    = 7001
MEMORY_FOR_QUERIES             = 10
CACHE_MAX_SIZE_GB              = 5
CACHE_MAX_SIZE_GB_SINGLE_ENTRY = 1
CACHE_MAX_NUM_ENTRIES          = 100

# QLever UI
QLEVERUI_PORT   = 7000
QLEVERUI_DIR    = ${QLEVERUI_DIR}
QLEVERUI_CONFIG = ${QLEVERUI_CONFIG}

EOT
    cat << EOT
There was no Qleverfile in this directory yet. A Qleverfile contains
basic configuration telling the "qlever" command how to do certain
things. The following basic Qleverfile was now created:

${BLUE}$(cat Qleverfile)${NORMAL}

EOT
  fi

  # QLever UI: if the repo is not there yet, download it via GitHub.
  #
  # TODO: For now, just have a working copy for each QLever instance. One central
  # working copy would be also fine, but it also doesn't hurt because it's less
  # than 50 MB large.
  if [ ! -d ${QLEVERUI_DIR} ]; then
    cat << EOT
${BOLD}Downloading and building QLever UI ...${NORMAL}

Downloading a copy from ${QLEVERUI_GIT} (it's small) and building the docker
image from it. This requires that you have docker installed. Stay tuned if you
want to use the QLever UI without docker. Also, if you just want to interact
with a QLever server via API, you don't need the QLever UI.
EOT
    echo && echo
    git clone ${QLEVERUI_GIT} ${QLEVERUI_DIR}
    echo 
    # QLEVERUI_BUILD_LOG="qleverui.build-log.txt"
    # echo "Building docker image \"${QLEVERUI_DOCKER_IMAGE}\", log in \"${QLEVERUI_BUILD_LOG}\" ..."
    # echo
    # (cd ${QLEVERUI_DIR} && docker build -t ${QLEVERUI_DOCKER_IMAGE} . \
    #     | > qleverui.build-log.txt)
  fi

  # DONE: give the user a short heads up what they can do now.
  cat << EOT
${BOLD}Setup is complete${NORMAL}

Type "qlever" and use autocompletion to see which actions are available. Add a
"show" in the end to see what an action does without executing it (for example,
"qlever index show"). Typing "qlever" without arguments gives you overview over
the basic configuration. Edit your local "Qleverfile" to change settings.

EOT
  eval ${EXIT}
fi


#   cat << EOT | tr '\n' ' ' | fold -s
#     ${BOLD}Resetting configuration${NORMAL}
#     
#     Regenerating the completions. The QLeverfile is not regenerated. If you want to
#     regenerate it, remove it and run ". qlever reset" again.
# 
# EOT
#   complete -r qlever 2> /dev/null
#   rm -f qlever.completions




###
### WHAT THE SCRIPT ACTUALLY DOES (it's basically a wrapper for "make")
###
 
# First separate the variable assignment arguments from the others. The
# assignment will go in VARS, the rest will stay in $@ (both arrays).
VARS=( "QLEVER_CMD=${QLEVER_CMD}" "QLEVER_CMD_DIR=${QLEVER_CMD_DIR}" )
OPT=""
for ARG do
  shift
  [[ "${ARG}" =~ ^--$ ]] && OPT="${ARG}" && continue
  [[ "${ARG}" =~ ^[A-Z_]+= ]] && VARS+=( "${ARG}" ) && continue
  set -- "$@" "${ARG}"
done
# for VAR in "${VARS[@]}"; do echo "VAR = \"${VAR}\""; done
# for ARG in "$@"; do echo "ARG = \"${ARG}\""; done
# echo

# Docker handling.
QLEVER_DOCKER_IMAGE=adfreiburg/qlever
QLEVER_DOCKER_CONTAINER=qlever
function is_docker_running {
  if [ "$(docker container inspect -f '{{.State.Running}}' ${QLEVER_DOCKER_CONTAINER} 2> /dev/null)" == "true" ]; then
    return 0
  else
    return 1
  fi
}
if is_docker_running && [[ "$*" != "docker-off"* ]]; then
  if [ -z "${OPT}" ]; then
    echo "${BOLD}${MAGENTA}DOCKER ACTIVATED (found a running container named \"${QLEVER_DOCKER_CONTAINER}\"), to force NATIVE use \"qlever -- ...\"${NORMAL}"
    echo
    echo "Continuing with running your command inside this docker container:"
    echo
    DOCKER_QLEVER_CMD="docker exec -it ${QLEVER_DOCKER_CONTAINER} bash -c \"cd /index && ./qlever $@\""
    echo "${BLUE}${DOCKER_QLEVER_CMD}${NORMAL}"
    echo
    eval "${DOCKER_QLEVER_CMD}" | sed '1,3d'
    # echo "${MAGENTA}${BOLD}DOCKER EXEC done -> explicit EXIT${NORMAL}"
    # echo
    eval "${EXIT}"
  else
    # DEBUG: (last) Show optional argument if it exists.
    if [ ! -z "${OPT}" ]; then
      echo "${MAGENTA}OPTION ${OPT} PROVIDED -> force NATIVE mode despite running docker container${NORMAL}"
      echo
    fi
  fi
fi

# When calling script with no arguments, show the config. TODO: Give the user
# some more information here.
# if [ -z "$*" ]; then
#   # qlever_make "${VARS[@]}"
#   if [ "${BASH_COMPLETION}" == "0" ]; then
#     echo "${RED}Completions deactivated (set BASH_COMPLETION = 1 in Qleverfile to activate)${NORMAL}"
#     echo
#   elif [ ! -z "${QLEVER_COMPLETIONS}" ]; then
#     cat << EOT
# All completions:
# 
# ${BLUE}$(echo ${QLEVER_COMPLETIONS} | fold -s)${NORMAL}
# 
# To see what a particular command would do (without executing it), just type
# something like "qlever index show" (single command) or "qlever start log show"
# (multiple commands)
# 
# EOT
#   fi
#   eval ${EXIT}
# fi

# When no arguments or "help", show help info.
if [ -z "$*" ] || [ "$*" == "help" ]; then
  qlever_help
  eval ${EXIT}
fi

# If the last argument is "show", just show the commands, but don't execute
# them. The first for loop is a portable hack to get the last argument.
for LAST; do true; done
if [ "${LAST}" == "show" ]; then
  echo "${BOLD}Just showing what would be executed${NORMAL}"
  echo
  for ARG in "$@"; do
    if [ "${ARG}" != "show" ]; then
      echo "\"${ARG}\" would execute the following:"
      echo
      qlever_make_show "${VARS[@]}" "${ARG}"
      echo
    fi
  done
  eval ${EXIT}
fi

# Normal execution of script using make with two Makefiles. The first Makefile
# is everything after __DATA__ below (that part is used as the master
# Qleverfile and by having it here, we avoid having two files). The second
# Makefile is the Qleverfile in this directory
# 
# First show the command before executing it (make -n).
for ARG in "$@"; do
  echo "${BOLD}Executing \"${ARG}\":${NORMAL}"
  echo
  # TODO: Handle non-existing commands more gracefully, currently an error
  # message from "make" is shown (twice).
  if qlever_make_show "${VARS[@]}" "${ARG}" ; then
    echo
    qlever_make "${VARS[@]}" "${ARG}"
  fi
  echo
done

eval ${EXIT}



###
### The master Qleverfile = Makefile (everything after __DATA__)
###

__DATA__
SHELL=/bin/bash
.DEFAULT_GOAL=show-config.HIDDEN

# PIN WARMUP QUERIES TO CACHE (for the QLever UI)
# (c) Algorithms and Data Structures, University of Freiburg
# Originally written by Hannah Bast, 20.02.2021

# This Makefile provides the following targets:
#
# pin: Pin queries to cache, so that all autocompletion queries are fast, even
#      when "Clear cache" is clicked in the QLever UI (ther results for pinned 
#      queries will never be removed, unless ... see target clear).
#
# clear: Clear the cache completely (including pinned results). Note that this
#        can NOT be activated from the QLever UI.
#
# clear-unpinned: Clear all unpinned results from the cache. This is exactly
#                 what happens when clicking "Clear cache" in the QLever UI.
#
# show-all-ac-queries: Show the AC queries for subject, predicat, object for
#                      copy&paste in the QLever UI backend settings.

# This Makefile should be used as follows:
#
# 1. In the directors with the particular index, create a new Makefile
# 2. At the top add: include /local/data/qlever/qlever-indices/Makefile
#    (or wherever this Makefile - the master Makefile - resides)
# 3. Redefine API and FREQUENT_PREDICATES (see below) in the local Makefile
# 4. Redefine any of the patterns in the local Makefile
#    (the patterns below give a default functionality, which should work
#    for any knowledge base, but only using the raw IRIs, and no names,
#    aliases, or whatever special data the knowledge base has to offer.

# A prefix that identifies a particular build. This typically consists of a base
# name and optionally further specificataion separated by dots. For example:
# wikidata. Or: wikidata.2021-06-27
DB=

# The base name of the prefix=the part before the first dot. Often, the name
# of the input (ttl) file or of the settings (json) file use only the basename
# and not the full prefix.
DB_BASE=$(firstword $(subst ., ,$(DB)))

# The port of the QLever backend.
HOSTNAME=must_specify
SERVER_PORT=must_specify

# The port of QLever UI.
QLEVERUI_PORT=7000

# The slug used in the URL of the QLever API and the QleverUI API. This is
# typically the basename of the prefix. For example: wikidata. Or: freebase.
SLUG=$(DB_BASE)

# Memory for queries and for the cache (all in GB).
MEMORY_FOR_QUERIES=30
CACHE_MAX_SIZE_GB=30
CACHE_MAX_SIZE_GB_SINGLE_ENTRY=5
CACHE_MAX_NUM_ENTRIES=1000

# The local API of the server.
SERVER_API=http://$(HOSTNAME):$(SERVER_PORT)

# The URL of the QLever backend.
QLEVER_API=https://qlever.cs.uni-freiburg.de/api/$(SLUG)

# The URL of the QLever UI istance ... TODO: it's confusing that this also has
# /api/ in the name, it actually has nothing to do with the URLs from the QLever
# backends (which are defined in the Apache configuration of QLever).
WARMUP_API=$(subst /api/,/api/warmup/,$(QLEVER_API))

# Admin token
TOKEN=aof4Ad

# Frequent predicates that should be pinned to the cache (can be left empty).
# Separate by space. You can use all the prefixes from PREFIXES (e.g. wdt:P31 if
# PREFIXES defines the prefix for wdt), but you can also write full IRIs. Just
# see how it is used in target pin: below, it's very simple.
FREQUENT_PREDICATES =
FREQUENT_PATTERNS_WITHOUT_ORDER =

# Directory with the QLever binaries.
QLEVER_BIN_DIR=/local/data/qlever/qlever-code/build

# Docker-related variables.
USE_DOCKER =
DOCKER_IMAGE=adfreiburg/qlever:latest
DOCKER_CONTAINER=qlever.$(DB)

# Configuration for SPARQL+Text.
QLEVER_TOOL_DIR=$(dir $(lastword $(MAKEFILE_LIST)))misc
WITH_TEXT=0

# Activate text options iff WITH_TEXT is one of: true yes 1. Don't forget the
# leading whitespace because this is appended to the other options.
WITH_TEXT_EMPTY_IF_FALSE=$(findstring $(WITH_TEXT),true yes 1)
TEXT_OPTIONS_INDEX=$(if $(WITH_TEXT_EMPTY_IF_FALSE), -w $(DB).wordsfile.tsv -d $(DB).docsfile.tsv,)
TEXT_OPTIONS_START=$(if $(WITH_TEXT_EMPTY_IF_FALSE), -t,)

show-config.HIDDEN:
	echo "Basic configuration variables:" #
	echo -e "\033[34m" #
	for VAR in DB SLUG RDF_FILES CAT_FILES WITH_TEXT SERVER_PORT \
	  MEMORY_FOR_QUERIES CACHE_MAX_SIZE_GB CACHE_MAX_SIZE_GB_SINGLE_ENTRY CACHE_MAX_NUM_ENTRIES \
	  QLEVER_BIN_DIR USE_DOCKER DOCKER_IMAGE DOCKER_CONTAINER; do \
	  printf "%-30s = %s\n" "$$VAR" "$${!VAR}"; done
	printf "\033[0m" #

# Target for exporting selected variables. This is used by the "qlever" script
# to get access to some of the variable from the Qleverfile. Note that the value
# exported is not the literal value, but the value as interpreted by make (just
# as it would do in commands). For example, an assigment PORT = $$(echo "7001 +
# 1" | bc) would be exported as PORT=7002.
# 
# NOTE: We could also export the values literally using something like $(info
# PORT=$(PORT)), but that is not what we want here.
export.HIDDEN:
	@ for VAR in BASH_COMPLETION USE_DOCKER QLEVER_BIN_DIR; do \
	  echo "$$VAR=$${!VAR}"; done \

# Activate docker.
QLEVER_CMD=
QLEVER_CMD_DIR=
QLEVER_DOCKER_IMAGE=adfreiburg/qlever
QLEVER_DOCKER_CONTAINER=qlever
docker-on:
	echo "Activating docker ..." #
	echo #
	docker rm -f $(QLEVER_DOCKER_CONTAINER) 2> /dev/null #
	docker run -d -u $$(id -u):$$(id -g) -it -v $$(pwd):/index -p 7019:7019 --entrypoint bash --name $(QLEVER_DOCKER_CONTAINER) $(QLEVER_DOCKER_IMAGE) > /dev/null 2>&1
	docker cp $(QLEVER_CMD_DIR)/qlever qlever:/index
	printf "\033[34m" #
	docker ps | tr -s " " | grep "$(QLEVER_DOCKER_CONTAINER) " #
	echo -e "\033[0m" #
	echo "Server actions will now be executed via the docker container \"$(QLEVER_DOCKER_CONTAINER)\"" #

docker-off:
	echo "Deactivating docker ..." #
	docker rm -f $(QLEVER_DOCKER_CONTAINER) 2> /dev/null > /dev/null
	# docker ps | tr -s " " | grep "$(QLEVER_DOCKER_CONTAINER) " #
	echo #
	echo "Server actions will now be executed via the binaries \"IndexBuilderMain\" and \"ServerMain\" (assuming they are in your PATH)"

# Update the qlever script (locate, check whether it's a git working copy, git
# pull). Note: When this is called by the qlever script, QLEVER_CMD and
# QLEVER_CMD_DIR are from there via VARS.
# TODO: Is the method via VARS sufficiently generic or is there a better way?
update:
	echo "Updating \"qlever\" script ..." #
	echo #
	if [ ! -d "$(QLEVER_CMD_DIR)/.git" ]; then #\
	  echo -e "\033[31mDid not find directory \".git\" in \"${QLEVER_CMD_DIR}\"\033[0m" #\
	  echo; fi #\
	cd $(QLEVER_CMD_DIR) && git pull

where:
	echo "The absolute path of the directory where the \"qlever\" script is located..." #
	echo -e "\033[34m" #
	cd -- "$$(dirname -- "$(QLEVER_CMD)")" &> /dev/null && pwd
	printf "\033[0m" #

# Pull new image if image name contains a /

docker-pull.HIDDEN:
	@ if [[ "$(DOCKER_IMAGE)" == */* ]]; then docker pull $(DOCKER_IMAGE); fi
	@ docker images -f "reference=$(DOCKER_IMAGE)"

# Produce list of all input files.
rdf-files:
	ls $(RDF_FILES)

# Produce the input as fed to the index builder.
cat-files:
	eval $(CAT_FILES)

# Building an index.
QLEVER_INDEX_CMD=IndexBuilderMain
QLEVER_INDEX_OPTIONS=-F ttl -K $(DB) -f - -l -i $(DB) $(TEXT_OPTIONS_INDEX) -s $(DB_BASE).settings.json
index:
	if ls $(DB).index.* 1> /dev/null 2>&1; then #\
	  echo -e "\033[31mIndex exists, delete it first with \"qlever remove_index\" (add \"show\" to find out what gets deleted)\033[0m"; else #\
          time ($(CAT_FILES) | $(QLEVER_INDEX_CMD) $(QLEVER_INDEX_OPTIONS) | tee $(DB).index.log.txt) \
	; fi #

# Removing an index.
remove_index:
	rm -f $(DB).index.* $(DB).vocabulary.* $(DB).prefixes $(DB).meta-data.json $(DB).index-log.txt
	echo "The index files have been removed." #


# Starting the server in the background. If it is still runing, issue a warning
# and don't start it. Note the # after the code that does this check -> it will
# hence not be shown by qlever_make_show.
QLEVER_START_CMD=ServerMain
QLEVER_START_OPTIONS=-i $(DB) -j 8 -m $(MEMORY_FOR_QUERIES) -c $(CACHE_MAX_SIZE_GB) -e $(CACHE_MAX_SIZE_GB_SINGLE_ENTRY) -k $(CACHE_MAX_NUM_ENTRIES) -p $(SERVER_PORT)$(TEXT_OPTIONS_START)
LOG_CMD=tail -f -n 10 $(DB).server-log.txt
start:
	if [ $$(curl --silent http://localhost:$(SERVER_PORT) > /dev/null; echo $$?) == 0 ]; then #\
	  echo -e "\033[31mServer already running on port ${SERVER_PORT}, to restart it first do \"stop\" (or check the PORT in your Qleverfile)\033[0m"; #\
	  echo -e "\033[34m"; #\
	  ps -e -o "%p" -o "  %U " -o start_time -o "  %a" | \grep "${QLEVER_START_CMD} .*-p ${SERVER_PORT}" | \grep -v "grep.*${QLEVER_START_CMD}"; #\
	  printf "\033[0m"; else #\
	  # echo && ps -ef | \grep "${QLEVER_START_CMD} .*-p ${SERVER_PORT}" | \grep -v "grep.*${QLEVER_START_CMD}" | tr -s " "; else #\
	echo "Starting the QLever server in the background and waiting till it's ready (Ctrl+C will not kill it) ..." && echo #\
	$(QLEVER_START_CMD) $(QLEVER_START_OPTIONS) > $(DB).server-log.txt & \
	$(LOG_CMD) & PID=$$!; while [ $$(curl --silent http://localhost:$(SERVER_PORT) > /dev/null; echo $$?) != 0 ]; \
	   do sleep 1; done; kill $${PID}; fi

# Command line for showing the log and following it.
log:
	echo "Showing the log (abort with Ctrl+C) ..." #
	echo #
	$(LOG_CMD)

# Command line for stopping the server. NOTE: This also pays attention that the
# index name fits.
STOP_CMD_NATIVE=$$(while read PID; do kill $$PID 2> /dev/null; sed -i "/^$$PID$$/d" $(DB).pid; done < $(DB).pid)
STOP_CMD_DOCKER=docker stop $(DOCKER_CONTAINER)
STOP_CMD=$(if $(USE_DOCKER),$(STOP_CMD_DOCKER),$(STOP_CMD_NATIVE))
stop:
	echo "Stop the QLever server (find and kill manually if it fails) ..." #
	PS=$$(ps -e -o "%p" -o "  %U " -o start_time -o "  %a" | \grep "$(QLEVER_START_CMD) -i [^ ]*$(DB)") && PID=$$(echo $${PS} | cut -d " " -f 1) && kill $${PID} \
	  2> /dev/null && echo && echo -e "\033[34m$${PS}\033[0m" && echo && echo "Killed process with PID $${PID}" || #\
          (echo && echo -e "\033[31mDid not find a running server for \"$(DB)\" or could not kill it, try \"qlever status\"\033[0m") #

status:
	echo "Showing all processes with command \"$(QLEVER_START_CMD)\" on this machine ..." #
	echo -e "\033[34m" #
	ps -e -o "%p" -o "  %U " -o start_time -o "  %a" | \grep "${QLEVER_START_CMD}" | \grep -v "grep.*${QLEVER_START_CMD}"
	printf "\033[0m" #

wait:
	$(LOG_CMD) & PID=$$!; \
	 while [ $$(curl --silent http://localhost:$(SERVER_PORT) > /dev/null; echo $$?) != 0 ]; \
	   do sleep 1; done; kill $$PID


# Create wordsfile and docsfile from all literals of the given NT file.
# Using this as input for a SPARQL+Text index build will effectively enable
# keyword search in literals. To understand how, look at the wordsfile and
# docsfile produced. See git:ad-freiburg/qlever/docs/sparql_and_text.md .
#
# TODO: Enable again, but need a checkout of the QLever repo.
#
# text_input_from_nt_literals:
#	python3 $(QLEVER_TOOL_DIR)/words-and-docs-file-from-nt.py $(DB)

# Warmup queries for the autocompletion.
# 
# TODO: This requires a running QLever UI and his currently hard-coded to use
# instances on particular machine (galera.informatik.privat). It will be fixed
# soon.
#
# NOTE: We need -tt here because the "qlever" script calls "make" via a pipe and
# so it does not have a terminal (the error message is "Pseudo-terminal will not
# be allocated because stdin is not a terminal." and "the input device is not a
# TTY"). The manpage for ssh says: "Multiple -t options force tty allocation,
# even if ssh has no local tty." and "-tt" is just a shorthand for "-t -t".in.master:
pin.INTERNAL:
	echo "Launch warmup queries for the QLever UI autocompletion (via galera) ..." #
	ssh -tt galera docker exec -it qlever-ui bash -c \"python manage.py warmup $(SLUG) pin\"

# pin.local:
# 	docker exec -it qlever-ui bash -c "python manage.py warmup $(SLUG) pin"
# 
# clear.local:
# 	docker exec -it qlever-ui bash -c "python manage.py warmup $(SLUG) clear"
# 
# clear_unpinned.local:
# 	docker exec -it qlever-ui bash -c "python manage.py warmup $(SLUG) clear_unpinned"

# Clear the cache.

clear-cache:
	echo "Clearing the cache (unpinned entries only) ..." #
	curl -Gs $(SERVER_API) --data-urlencode "cmd=clear-cache" > /dev/null
	curl -Gs $(SERVER_API) --data-urlencode "cmd=cache-stats" \
	  | sed 's/[{}",]//g; s/:/: /g; s/^\s\+//' | tr -s " " | numfmt --field=2,5,8,11,14 --grouping #

clear-cache-complete:
	echo "Clearing the cache completely (including pinned entries) ..." #
	curl -Gs $(SERVER_API) --data-urlencode "cmd=clear-cache-complete" > /dev/null
	curl -Gs $(SERVER_API) --data-urlencode "cmd=cache-stats" \
	  | sed 's/[{}",]//g; s/:/: /g; s/^\s\+//' | tr -s " " | numfmt --field=2,5,8,11,14 --grouping #

# Get various settings and statistics.

disk-usage:
	echo "Disk usage of all files in this QLever index, and the size of the input files" && echo #
	du -hc $(DB).index.[ops]* $(DB).vocabulary.* $(DB).prefixes $(DB).meta-data.json
	echo #
	# echo && echo "For comparison, the size of the input files" && echo #
	du -hc $(RDF_FILES)

cache-stats:
	echo "Show cache statistics (in number of IDs, an ID has 8 bytes) ..." #
	curl -Gs $(SERVER_API) --data-urlencode "cmd=cache-stats" \
	  | sed 's/[{}",]//g; s/:/: /g; s/^\s\+//' | tr -s " " | numfmt --field=2,5,8,11,14 --grouping #

memory-usage:
	@echo && docker stats --no-stream --format \
	  "Memory usage of docker container $(DOCKER_CONTAINER): {{.MemUsage}}" $(DOCKER_CONTAINER)

server-settings:
	echo "Getting settings from \"${SERVER_API}\" ..." #
	curl -Gs $(SERVER_API) --data-urlencode "cmd=get-settings" \
	  | sed 's/[{}",]//g; s/:/: /g; s/^\s\+//' | tr -s " " #

# QLever UI (work in progress).
LOG_FILE=qleverui-log.tmp
ERROR_CMD=(echo && echo -e "\033[31mAn error occured, check $(LOG_FILE) for details, the last 10 lines are:\033[0m" && tail $(LOG_FILE) && false)
QLEVERUI_GIT=git@github.com:ad-freiburg/qlever-ui.git
ui:
	> $(LOG_FILE) #
	# echo "Downloading QLever UI (unless it's already there) ..." #
	# if [ ! -d "$(QLEVERUI_DIR)" ]; then date && git clone "$(QLEVERUI_GIT)" "$(QLEVERUI_DIR)" && date; fi \ #
	#  >> $(LOG_FILE) 2>&1 || $(ERROR_CMD) #
	echo "Creating configuration for the QLever UI ..." #
	$(MAKE) -s -C "$(QLEVERUI_DIR)" CONFIG_SLUG=$(QLEVERUI_CONFIG) BACKEND_PORT=$(SERVER_PORT) overwrite_config \
	  >> $(LOG_FILE) 2>&1 || $(ERROR_CMD) #
	echo "Launching QLever UI web application ..." #
	$(MAKE) -s -C $(QLEVERUI_DIR) HOSTNAME=$(HOSTNAME) FRONTEND_PORT=$(QLEVERUI_PORT) qlever-ui \
	  >> $(LOG_FILE) 2>&1 || $(ERROR_CMD) #
	# echo "Warmup queries for fast autocompletion (check HOSTNAME and PORTs if something goes wrong here) ..." #
	# $(QLEVERUI_MAKE) -s CONFIG_SLUG=$(CONFIG_SLUG) QLEVERUI_CONTAINER=$(QLEVERUI_CONTAINER) warmup >> $(LOG_FILE) 2>&1 || $(ERROR_CMD) #
	echo #
	echo "Looks like it worked, go to http://$(HOSTNAME):$(QLEVERUI_PORT) and try out some queries. If it doesn't work, check \"$(LOG_FILE)\" for suspicious messages or \"$(QLEVERUI_DIR)/Makefile\" for troubleshooting help" | fold -s #
	# (MAKE) -s -C "${QLEVERUI_DIR}" FRONTEND_PORT=$(QLEVERUI_PORT) BACKEND_PORT=$(SERVER_PORT) CONFIG_SLUG=$(DB) #

autocompletion-warmup:
	echo "Launch warmup queries for the QLever UI autocompletion ..." #
	docker exec -i qlever-ui bash -c "python manage.py warmup $(QLEVERUI_CONFIG) pin" \
	  >> $(LOG_FILE) 2>&1 || $(ERROR_CMD) #
	
export
